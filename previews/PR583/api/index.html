<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Interpolations.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Interpolations.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../convenience-construction/">Convenience Constructors</a></li><li><a class="tocitem" href="../interpolations/">General usage</a></li><li><a class="tocitem" href="../control/">Interpolation algorithms</a></li><li><a class="tocitem" href="../extrapolation/">Extrapolation</a></li><li><a class="tocitem" href="../iterate/">Knot Iteration</a></li><li><a class="tocitem" href="../devdocs/">Developer documentation</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Internal-API"><span>Internal API</span></a></li></ul></li><li><a class="tocitem" href="../NEWS/">News and Changes</a></li><li><a class="tocitem" href="../other_packages/">Other Interpolation Packages</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/Interpolations.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChainRulesCore.rrule-Tuple{AbstractInterpolation, Vararg{Any, N} where N}" href="#ChainRulesCore.rrule-Tuple{AbstractInterpolation, Vararg{Any, N} where N}"><code>ChainRulesCore.rrule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ChainRulesCore.rrule(itp::AbstractInterpolation, x...)</code></pre><p>ChainRulesCore.jl <code>rrule</code> for integration with automatic differentiation libraries. Note that it gives the gradient only with respect to the evaluation point <code>x</code>, and not the data inside <code>itp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/chainrules/chainrules.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.bounds-Tuple{AbstractInterpolation}" href="#Interpolations.bounds-Tuple{AbstractInterpolation}"><code>Interpolations.bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bounds(itp::AbstractInterpolation)</code></pre><p>Return the <code>bounds</code> of the domain of <code>itp</code> as a tuple of <code>(min, max)</code> pairs for each coordinate. This is best explained by example:</p><pre><code class="language-julia-repl hljs">julia&gt; itp = interpolate([1 2 3; 4 5 6], BSpline(Linear()));

julia&gt; bounds(itp)
((1, 2), (1, 3))

julia&gt; data = 1:3;

julia&gt; knots = ([10, 11, 13.5],);

julia&gt; itp = interpolate(knots, data, Gridded(Linear()));

julia&gt; bounds(itp)
((10.0, 13.5),)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L133-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.constant_interpolation" href="#Interpolations.constant_interpolation"><code>Interpolations.constant_interpolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">etp = constant_interpolation(knots, A; extrapolation_bc=Throw())</code></pre><p>A shorthand for <code>extrapolate(interpolate(knots, A, scheme), extrapolation_bc)</code>, where <code>scheme</code> is either <code>BSpline(Constant())</code> or <code>Gridded(Constant())</code> depending on whether <code>knots</code> are ranges or vectors.</p><p>Consider using <code>interpolate</code> or <code>extrapolate</code> explicitly as needed rather than using this convenience constructor. Performance will improve without extrapolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/convenience-constructors.jl#L46-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.cubic_spline_interpolation" href="#Interpolations.cubic_spline_interpolation"><code>Interpolations.cubic_spline_interpolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">etp = cubic_spline_interpolation(knots, A; bc=Line(OnGrid()), extrapolation_bc=Throw())</code></pre><p>A shorthand for <code>extrapolate(scale(interpolate(A, BSpline(Cubic(bc))),knots), extrapolation_bc)</code>.</p><p>Consider using <code>interpolate</code>, <code>scale</code>, or <code>extrapolate</code> explicitly as needed rather than using this convenience constructor. Performance will improve without scaling or extrapolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/convenience-constructors.jl#L59-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.extrapolate-Union{Tuple{ET}, Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T, N, IT}, ET}} where {T, N, IT, ET&lt;:Union{Tuple{Vararg{Union{Tuple{Interpolations.BoundaryCondition, Interpolations.BoundaryCondition}, Interpolations.BoundaryCondition}, N} where N}, Interpolations.BoundaryCondition}}" href="#Interpolations.extrapolate-Union{Tuple{ET}, Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T, N, IT}, ET}} where {T, N, IT, ET&lt;:Union{Tuple{Vararg{Union{Tuple{Interpolations.BoundaryCondition, Interpolations.BoundaryCondition}, Interpolations.BoundaryCondition}, N} where N}, Interpolations.BoundaryCondition}}"><code>Interpolations.extrapolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>extrapolate(itp, scheme)</code> adds extrapolation behavior to an interpolation object, according to the provided scheme.</p><p>The scheme can take any of these values:</p><ul><li><code>Throw</code> - throws a BoundsError for out-of-bounds indices</li><li><code>Flat</code> - for constant extrapolation, taking the closest in-bounds value</li><li><code>Line</code> - linear extrapolation (the wrapped interpolation object must support gradient)</li><li><code>Reflect</code> - reflecting extrapolation (indices must support <code>mod</code>)</li><li><code>Periodic</code> - periodic extrapolation (indices must support <code>mod</code>)</li></ul><p>You can also combine schemes in tuples. For example, the scheme <code>(Line(), Flat())</code> will use linear extrapolation in the first dimension, and constant in the second.</p><p>Finally, you can specify different extrapolation behavior in different direction. <code>((Line(),Flat()), Flat())</code> will extrapolate linearly in the first dimension if the index is too small, but use constant etrapolation if it is too large, and always use constant extrapolation in the second dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/extrapolation/extrapolation.jl#L25-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.extrapolate-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T, N, IT}, Any}} where {T, N, IT}" href="#Interpolations.extrapolate-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T, N, IT}, Any}} where {T, N, IT}"><code>Interpolations.extrapolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>extrapolate(itp, fillvalue)</code> creates an extrapolation object that returns the <code>fillvalue</code> any time the indexes in <code>itp(x1,x2,...)</code> are out-of-bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/extrapolation/filled.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.interpolate!-Union{Tuple{IT}, Tuple{TWeights}, Tuple{Type{TWeights}, AbstractArray, IT}} where {TWeights, IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline}, N} where N}, BSpline}}" href="#Interpolations.interpolate!-Union{Tuple{IT}, Tuple{TWeights}, Tuple{Type{TWeights}, AbstractArray, IT}} where {TWeights, IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline}, N} where N}, BSpline}}"><code>Interpolations.interpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>In-place version of <code>interpolate</code>. It destroys input <code>A</code> and may trim the domain at the endpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/b-splines.jl#L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray, IT, Real, Int64}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline}, N} where N}, BSpline}" href="#Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray, IT, Real, Int64}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline}, N} where N}, BSpline}"><code>Interpolations.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">itp = interpolate(A, interpmode, gridstyle, λ, k)</code></pre><p>Interpolate an array <code>A</code> in the mode determined by <code>interpmode</code> and <code>gridstyle</code> with regularization following [1], of order <code>k</code> and constant <code>λ</code>.  <code>interpmode</code> may be one of</p><ul><li><code>BSpline(NoInterp())</code></li><li><code>BSpline(Linear())</code></li><li><code>BSpline(Quadratic(BC()))</code> (see <a href="#Interpolations.BoundaryCondition"><code>BoundaryCondition</code></a>)</li><li><code>BSpline(Cubic(BC()))</code></li></ul><p>It may also be a tuple of such values, if you want to use different interpolation schemes along each axis.</p><p><code>gridstyle</code> should be one of <code>OnGrid()</code> or <code>OnCell()</code>.</p><p><code>k</code> corresponds to the derivative to penalize. In the limit λ-&gt;∞, the interpolation function is a polynomial of order <code>k-1</code>. A value of 2 is the most common.</p><p><code>λ</code> is non-negative. If its value is zero, it falls back to non-regularized interpolation.</p><p>[1] https://projecteuclid.org/euclid.ss/1038425655.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/b-splines.jl#L194-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray, IT}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline}, N} where N}, BSpline}" href="#Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray, IT}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline}, N} where N}, BSpline}"><code>Interpolations.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">itp = interpolate(A, interpmode)</code></pre><p>Interpolate an array <code>A</code> in the mode determined by <code>interpmode</code>. <code>interpmode</code> may be one of</p><ul><li><code>NoInterp()</code></li><li><code>BSpline(Constant())</code></li><li><code>BSpline(Linear())</code></li><li><code>BSpline(Quadratic(bc))</code> (see <a href="#Interpolations.BoundaryCondition"><code>BoundaryCondition</code></a>)</li><li><code>BSpline(Cubic(bc))</code></li></ul><p>It may also be a tuple of such values, if you want to use different interpolation schemes along each axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/b-splines.jl#L176-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.interpolate-Union{Tuple{IT}, Tuple{N}, Tuple{Tel}, Tuple{Tuple{Vararg{Union{AbstractVector{T}, Tuple} where T, N}}, AbstractArray{Tel, N}, IT}} where {Tel, N, IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded}, N} where N}, Gridded}}" href="#Interpolations.interpolate-Union{Tuple{IT}, Tuple{N}, Tuple{Tel}, Tuple{Tuple{Vararg{Union{AbstractVector{T}, Tuple} where T, N}}, AbstractArray{Tel, N}, IT}} where {Tel, N, IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded}, N} where N}, Gridded}}"><code>Interpolations.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">itp = interpolate((nodes1, nodes2, ...), A, interpmode)</code></pre><p>Interpolate an array <code>A</code> on a non-uniform but rectangular grid specified by the given <code>nodes</code>, in the mode determined by <code>interpmode</code>.</p><p><code>interpmode</code> may be one of</p><ul><li><code>NoInterp()</code></li><li><code>Gridded(Constant())</code></li><li><code>Gridded(Linear())</code></li></ul><p>It may also be a tuple of such values, if you want to use different interpolation schemes along each axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/gridded/gridded.jl#L151-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.knots-Tuple{AbstractInterpolation}" href="#Interpolations.knots-Tuple{AbstractInterpolation}"><code>Interpolations.knots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">knots(itp::AbstractInterpolation)
knots(etp::AbstractExtrapolation)</code></pre><p>Returns an iterator over knot locations for an AbstractInterpolation or AbstractExtrapolation.</p><p>Iterator will yield scalar values for interpolations over a single dimension, and tuples of coordinates for higher dimension interpolations. Iteration over higher dimensions is taken as the product of knots along each dimension.</p><p>ie. Iterator.product(knots on first dim, knots on 2nd dim,...)</p><p>Extrapolations with Periodic or Reflect boundary conditions, will produce an infinite sequence of knots.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Interpolations;

julia&gt; etp = linear_interpolation([1.0, 1.2, 2.3, 3.0], rand(4); extrapolation_bc=Periodic());

julia&gt; Iterators.take(knots(etp), 5) |&gt; collect
5-element Vector{Float64}:
 1.0
 1.2
 2.3
 3.0
 3.2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/iterate.jl#L104-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.knotsbetween-Tuple{Any}" href="#Interpolations.knotsbetween-Tuple{Any}"><code>Interpolations.knotsbetween</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">knotsbetween(iter; start, stop)
knotsbetween(iter, start, stop)</code></pre><p>Iterate over all knots of <code>iter</code> such that <code>start &lt; k &lt; stop</code>.</p><p><code>iter</code> can be an <code>AbstractInterpolation</code>, or the output of <code>knots</code> (ie. a <code>KnotIterator</code> or <code>ProductIterator</code> wrapping <code>KnotIterator</code>)</p><p>If <code>start</code> is not provided, iteration will start from the first knot. An <code>ArgumentError</code> will be raised if both <code>start</code> and <code>stop</code> are not provided.</p><p>If no such knots exists will return a KnotIterator with length 0</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Interpolations;

julia&gt; etp = linear_interpolation([1.0, 1.2, 2.3, 3.0], rand(4); extrapolation_bc=Periodic());

julia&gt; knotsbetween(etp; start=38, stop=42) |&gt; collect
6-element Vector{Float64}:
 38.3
 39.0
 39.2
 40.3
 41.0
 41.2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/iterate.jl#L409-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.linear_interpolation" href="#Interpolations.linear_interpolation"><code>Interpolations.linear_interpolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">etp = linear_interpolation(knots, A; extrapolation_bc=Throw())</code></pre><p>A shorthand for one of the following.</p><ul><li><code>extrapolate(scale(interpolate(A, BSpline(Linear())), knots), extrapolation_bc)</code></li><li><code>extrapolate(interpolate(knots, A, Gridded(Linear())), extrapolation_bc)</code>,</li></ul><p>depending on whether <code>knots</code> are ranges or vectors.</p><p>Consider using <code>interpolate</code>, <code>scale</code>, or <code>extrapolate</code> explicitly as needed rather than using this convenience constructor. Performance will improve without scaling or extrapolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/convenience-constructors.jl#L32-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.scale-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T, N, IT}, Vararg{AbstractRange, N}}} where {T, N, IT}" href="#Interpolations.scale-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T, N, IT}, Vararg{AbstractRange, N}}} where {T, N, IT}"><code>Interpolations.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>scale(itp, xs, ys, ...)</code> scales an existing interpolation object to allow for indexing using other coordinate axes than unit ranges, by wrapping the interpolation object and transforming the indices from the provided axes onto unit ranges upon indexing.</p><p>The parameters <code>xs</code> etc must be either ranges or linspaces, and there must be one coordinate range/linspace for each dimension of the interpolation object.</p><p>For every <code>NoInterp</code> dimension of the interpolation object, the range must be exactly <code>1:size(itp, d)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/scaling/scaling.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.AkimaMonotonicInterpolation" href="#Interpolations.AkimaMonotonicInterpolation"><code>Interpolations.AkimaMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AkimaMonotonicInterpolation</code></pre><p>Monotonic interpolation based on Akima (1970), &quot;A New Method of Interpolation and Smooth Curve Fitting Based on Local Procedures&quot;, doi:10.1145/321607.321609.</p><p>Tangents are determined at each given point locally, results are close to manual drawn curves</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/monotonic/monotonic.jl#L71-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.BSpline" href="#Interpolations.BSpline"><code>Interpolations.BSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BSpline(degree)</code></pre><p>A flag signaling <code>BSpline</code> (integer-grid b-spline) interpolation along the corresponding axis. <code>degree</code> is one of <a href="#Interpolations.Constant"><code>Constant</code></a>, <a href="#Interpolations.Linear"><code>Linear</code></a>, <a href="#Interpolations.Quadratic"><code>Quadratic</code></a>, or <a href="#Interpolations.Cubic"><code>Cubic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/b-splines.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.CardinalMonotonicInterpolation" href="#Interpolations.CardinalMonotonicInterpolation"><code>Interpolations.CardinalMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CardinalMonotonicInterpolation(tension)</code></pre><p>Cubic cardinal splines, uses <code>tension</code> parameter which must be between [0,1] Cubin cardinal splines can overshoot for non-monotonic data (increasing tension reduces overshoot).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/monotonic/monotonic.jl#L60-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Constant" href="#Interpolations.Constant"><code>Interpolations.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Constant b-splines are <em>nearest-neighbor</em> interpolations, and effectively return <code>A[round(Int,x)]</code> when interpolating without scaling. Scaling can lead to inaccurate position of the <em>neighbors</em> due to limited numerical precision.</p><p><code>Constant{Previous}</code> interpolates to the previous value and is thus equivalent to <code>A[floor(Int,x)]</code> without scaling. <code>Constant{Next}</code> interpolates to the next value and is thus equivalent to <code>A[ceil(Int,x)]</code> without scaling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/constant.jl#L57-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Cubic" href="#Interpolations.Cubic"><code>Interpolations.Cubic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cubic(bc::BoundaryCondition)</code></pre><p>Indicate that the corresponding axis should use cubic interpolation.</p><p><strong>Extended help</strong></p><p>Assuming uniform knots with spacing 1, the <code>i</code>th piece of cubic spline implemented here is defined as follows.</p><pre><code class="nohighlight hljs">y_i(x) = cm p(x-i) + c q(x-i) + cp q(1- (x-i)) + cpp p(1 - (x-i))</code></pre><p>where</p><pre><code class="nohighlight hljs">p(δx) = 1/6 * (1-δx)^3
q(δx) = 2/3 - δx^2 + 1/2 δx^3</code></pre><p>and the values <code>cX</code> for <code>X ∈ {m, _, p, pp}</code> are the pre-filtered coefficients.</p><p>For future reference, this expands out to the following polynomial:</p><pre><code class="nohighlight hljs">y_i(x) = 1/6 cm (1+i-x)^3 + c (2/3 - (x-i)^2 + 1/2 (x-i)^3) +
         cp (2/3 - (1+i-x)^2 + 1/2 (1+i-x)^3) + 1/6 cpp (x-i)^3</code></pre><p>When we derive boundary conditions we will use derivatives <code>y_0&#39;(x)</code> and <code>y_0&#39;&#39;(x)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/cubic.jl#L11-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.CubicHermite" href="#Interpolations.CubicHermite"><code>Interpolations.CubicHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> CubicHermite</code></pre><p>This type is purposely left undocumented since the interface is expected to radically change in order to make it conform to the <code>AbstractInterpolation</code> interface. Consider this API to be highly unstable and non-public, and that breaking changes to this code could be made in a point release.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/hermite/cubic.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.FiniteDifferenceMonotonicInterpolation" href="#Interpolations.FiniteDifferenceMonotonicInterpolation"><code>Interpolations.FiniteDifferenceMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FiniteDifferenceMonotonicInterpolation</code></pre><p>Classic cubic interpolation, no tension parameter. Finite difference can overshoot for non-monotonic data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/monotonic/monotonic.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Flat" href="#Interpolations.Flat"><code>Interpolations.Flat</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Flat(gt)</code> sets the extrapolation slope to zero</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Free" href="#Interpolations.Free"><code>Interpolations.Free</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Free(gt)</code> the free boundary condition makes sure the interpoland has a continuous third derivative at the second-to-outermost cell boundary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.FritschButlandMonotonicInterpolation" href="#Interpolations.FritschButlandMonotonicInterpolation"><code>Interpolations.FritschButlandMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FritschButlandMonotonicInterpolation</code></pre><p>Monotonic interpolation based on  Fritsch &amp; Butland (1984), &quot;A Method for Constructing Local Monotone Piecewise Cubic Interpolants&quot;, doi:10.1137/0905021.</p><p>Faster than FritschCarlsonMonotonicInterpolation (only requires one pass) but somewhat higher apparent &quot;tension&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/monotonic/monotonic.jl#L96-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.FritschCarlsonMonotonicInterpolation" href="#Interpolations.FritschCarlsonMonotonicInterpolation"><code>Interpolations.FritschCarlsonMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FritschCarlsonMonotonicInterpolation</code></pre><p>Monotonic interpolation based on Fritsch &amp; Carlson (1980), &quot;Monotone Piecewise Cubic Interpolation&quot;, doi:10.1137/0717021.</p><p>Tangents are first initialized, then adjusted if they are not monotonic can overshoot for non-monotonic data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/monotonic/monotonic.jl#L84-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.InPlace" href="#Interpolations.InPlace"><code>Interpolations.InPlace</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>InPlace(gt)</code> is a boundary condition that allows prefiltering to occur in-place (it typically requires padding)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.InPlaceQ" href="#Interpolations.InPlaceQ"><code>Interpolations.InPlaceQ</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>InPlaceQ(gt)</code> is similar to <code>InPlace(gt)</code>, but is exact when the values being interpolated arise from an underlying quadratic. It is primarily useful for testing purposes, allowing near-exact (to machine precision) comparisons against ground truth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L105-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Lanczos" href="#Interpolations.Lanczos"><code>Interpolations.Lanczos</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Lanczos{N}(a=4)</code></pre><p>Lanczos resampling via a kernel with scale parameter <code>a</code> and support over <code>N</code> neighbors.</p><p>This form of interpolation is merely the discrete convolution of the samples with a Lanczos kernel of size <code>a</code>. The size is directly related to how &quot;far&quot; the interpolation will reach for information, and has <code>O(N^2)</code> impact on runtime. An alternative implementation matching <code>lanczos4</code> from OpenCV is available as Lanczos4OpenCV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/lanczos/lanczos.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Lanczos4OpenCV" href="#Interpolations.Lanczos4OpenCV"><code>Interpolations.Lanczos4OpenCV</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Lanczos4OpenCV()</code></pre><p>Alternative implementation of Lanczos resampling using algorithm <code>lanczos4</code> function of OpenCV: https://github.com/opencv/opencv/blob/de15636724967faf62c2d1bce26f4335e4b359e5/modules/imgproc/src/resize.cpp#L917-L946</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/lanczos/lanczos_opencv.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Line" href="#Interpolations.Line"><code>Interpolations.Line</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Line(gt)</code> uses a constant slope for extrapolation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Linear" href="#Interpolations.Linear"><code>Interpolations.Linear</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Linear()</code></pre><p>Indicate that the corresponding axis should use linear interpolation.</p><p><strong>Extended help</strong></p><p>Assuming uniform knots with spacing 1, the <code>i</code>th piece of linear b-spline implemented here is defined as follows.</p><pre><code class="nohighlight hljs">y_i(x) = c p(x) + cp p(1-x)</code></pre><p>where</p><pre><code class="nohighlight hljs">p(δx) = x</code></pre><p>and the values <code>cX</code> for <code>X ∈ {_, p}</code> are the coefficients.</p><p>Linear b-splines are naturally interpolating, and require no prefiltering; there is therefore no need for boundary conditions to be provided.</p><p>Also, although the implementation is slightly different in order to re-use the framework built for general b-splines, the resulting interpolant is just a piecewise linear function connecting each pair of neighboring data points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/linear.jl#L16-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.LinearMonotonicInterpolation" href="#Interpolations.LinearMonotonicInterpolation"><code>Interpolations.LinearMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearMonotonicInterpolation</code></pre><p>Simple linear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/monotonic/monotonic.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Nearest" href="#Interpolations.Nearest"><code>Interpolations.Nearest</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Default parameter for <code>Constant</code> that performs <em>nearest-neighbor</em> interpolation. Can optionally be specified as</p><pre><code class="nohighlight hljs">Constant() === Constant{Nearest}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/constant.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Next" href="#Interpolations.Next"><code>Interpolations.Next</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parameter for <code>Constant</code> that performs <em>next-neighbor</em> interpolations. Applied through </p><pre><code class="nohighlight hljs">Constant{Next}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/constant.jl#L23-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.NoInterp" href="#Interpolations.NoInterp"><code>Interpolations.NoInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>NoInterp()</code> indicates that the corresponding axis must use integer indexing (no interpolation is to be performed)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.OnCell" href="#Interpolations.OnCell"><code>Interpolations.OnCell</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>OnCell()</code> indicates that the boundary condition applies a half-gridspacing beyond the first &amp; last nodes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.OnGrid" href="#Interpolations.OnGrid"><code>Interpolations.OnGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>OnGrid()</code> indicates that the boundary condition applies at the first &amp; last nodes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Periodic" href="#Interpolations.Periodic"><code>Interpolations.Periodic</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Periodic(gt)</code> applies periodic boundary conditions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Previous" href="#Interpolations.Previous"><code>Interpolations.Previous</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parameter for <code>Constant</code> that performs <em>previous-neighbor</em> interpolations. Applied through  ´´´ Constant{Previous}() ´´´</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/constant.jl#L14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Quadratic" href="#Interpolations.Quadratic"><code>Interpolations.Quadratic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Quadratic(bc::BoundaryCondition)</code></pre><p>Indicate that the corresponding axis should use quadratic interpolation.</p><p><strong>Extended help</strong></p><p>Assuming uniform knots with spacing 1, the <code>i</code>th piece of quadratic spline implemented here is defined as follows:</p><pre><code class="nohighlight hljs">y_i(x) = cm p(x-i) + c q(x) + cp p(1-(x-i))</code></pre><p>where</p><pre><code class="nohighlight hljs">p(δx) = (δx - 1)^2 / 2
q(δx) = 3/4 - δx^2</code></pre><p>and the values for <code>cX</code> for <code>X ∈ {m,_,p}</code> are the pre-filtered coefficients.</p><p>For future reference, this expands to the following polynomial:</p><pre><code class="nohighlight hljs">y_i(x) = cm * 1/2 * (x-i-1)^2 + c * (3/4 - x + i)^2 + cp * 1/2 * (x-i)^2</code></pre><p>When we derive boundary conditions we will use derivatives <code>y_1&#39;(x-1)</code> and <code>y_1&#39;&#39;(x-1)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/quadratic.jl#L11-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Reflect" href="#Interpolations.Reflect"><code>Interpolations.Reflect</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Reflect(gt)</code> applies reflective boundary conditions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.SteffenMonotonicInterpolation" href="#Interpolations.SteffenMonotonicInterpolation"><code>Interpolations.SteffenMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteffenMonotonicInterpolation</code></pre><p>Monotonic interpolation based on Steffen (1990), &quot;A Simple Method for Monotonic Interpolation in One Dimension&quot;, http://adsabs.harvard.edu/abs/1990A%26A...239..443S</p><p>Only one pass, results usually between FritschCarlson and FritschButland.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/monotonic/monotonic.jl#L109-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Throw" href="#Interpolations.Throw"><code>Interpolations.Throw</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Throw(gt)</code> causes beyond-the-edge extrapolation to throw an error</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L91">source</a></section></article><h2 id="Internal-API"><a class="docs-heading-anchor" href="#Internal-API">Internal API</a><a id="Internal-API-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Interpolations.boundstep" href="#Interpolations.boundstep"><code>Interpolations.boundstep</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <em>half</em> the width of one step of the range.</p><p>This function is used to calculate the upper and lower bounds of <code>OnCell</code> interpolation objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/scaling/scaling.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.count_interp_dims-Union{Tuple{Type{ITP}}, Tuple{ITP}} where ITP&lt;:AbstractInterpolation" href="#Interpolations.count_interp_dims-Union{Tuple{Type{ITP}}, Tuple{ITP}} where ITP&lt;:AbstractInterpolation"><code>Interpolations.count_interp_dims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n = count_interp_dims(ITP)</code></pre><p>Count the number of dimensions along which type <code>ITP</code> is interpolating. <code>NoInterp</code> dimensions do not contribute to the sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.deduplicate_knots!-Tuple{Any}" href="#Interpolations.deduplicate_knots!-Tuple{Any}"><code>Interpolations.deduplicate_knots!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Interpolations.deduplicate_knots!(knots; move_knots = false)

Makes knots unique by incrementing repeated but otherwise sorted knots using `nextfloat`.
If keyword `move_knots` is true, then `nextfloat` will be applied successively until knots
are unique. Otherwise, a warning will be issued.

# Example

```jldoctest
julia&gt; knots = [-8.0, 0.0, 20.0, 20.0]
4-element Vector{Float64}:
-8.0
0.0
20.0
20.0

julia&gt; Interpolations.deduplicate_knots!(knots)
4-element Vector{Float64}:
-8.0
0.0
20.0
20.000000000000004

julia&gt; Interpolations.deduplicate_knots!([1.0, 1.0, 1.0, nextfloat(1.0), nextfloat(1.0)]; move_knots = true)
5-element Vector{Float64}:
1.0
1.0000000000000002
1.0000000000000004
1.0000000000000007
1.0000000000000009
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/gridded/gridded.jl#L88-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.gradient_weights" href="#Interpolations.gradient_weights"><code>Interpolations.gradient_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">w = gradient_weights(degree, δx)</code></pre><p>Compute the weights for interpolation of the gradient at an offset <code>δx</code> from the &quot;base&quot; position. <code>degree</code> describes the interpolation scheme.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Interpolations.gradient_weights(Linear(), 0.2)
(-1.0, 1.0)</code></pre><p>This defines the gradient of a linear interpolation at 3.2 as <code>y[4] - y[3]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L332-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.hessian_weights" href="#Interpolations.hessian_weights"><code>Interpolations.hessian_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">w = hessian_weights(degree, δx)</code></pre><p>Compute the weights for interpolation of the hessian at an offset <code>δx</code> from the &quot;base&quot; position. <code>degree</code> describes the interpolation scheme.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Interpolations.hessian_weights(Linear(), 0.2)
(0.0, 0.0)</code></pre><p>Linear interpolation uses straight line segments, so the second derivative is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L349-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.inner_system_diags" href="#Interpolations.inner_system_diags"><code>Interpolations.inner_system_diags</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dl, d, du = inner_system_diags{T,IT}(::Type{T}, n::Int, ::Type{IT})</code></pre><p>Helper function to generate the prefiltering equation system: generates the diagonals for a <code>n</code>-by-<code>n</code> tridiagonal matrix with eltype <code>T</code> corresponding to the interpolation type <code>IT</code>.</p><p><code>dl</code>, <code>d</code>, and <code>du</code> are intended to be used e.g. as in <code>M = Tridiagonal(dl, d, du)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/prefiltering.jl#L153-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.inner_system_diags-Union{Tuple{T}, Tuple{Type{T}, Int64, Cubic}} where T" href="#Interpolations.inner_system_diags-Union{Tuple{T}, Tuple{Type{T}, Int64, Cubic}} where T"><code>Interpolations.inner_system_diags</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic</code>: continuity in function value, first and second derivatives yields</p><pre><code class="nohighlight hljs">2/3 1/6
1/6 2/3 1/6
    1/6 2/3 1/6
       ⋱  ⋱   ⋱</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/cubic.jl#L93-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.lanczos-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Any}} where T" href="#Interpolations.lanczos-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Any}} where T"><code>Interpolations.lanczos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lanczos(x, a, n=a)</code></pre><p>Implementation of the <a href="https://en.wikipedia.org/wiki/Lanczos_resampling">Lanczos kernel</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/lanczos/lanczos.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.nextknotidx-Union{Tuple{ET}, Tuple{T}, Tuple{Interpolations.KnotIterator{T, ET}, Any}} where {T, ET}" href="#Interpolations.nextknotidx-Union{Tuple{ET}, Tuple{T}, Tuple{Interpolations.KnotIterator{T, ET}, Any}} where {T, ET}"><code>Interpolations.nextknotidx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextknotidx(iter::KnotIterator, x)</code></pre><p>Returns the index of the first knot such that <code>x &lt; k</code> or <code>nothing</code> if no such knot exists.</p><p>New boundary conditions should define:</p><pre><code class="nohighlight hljs">nextknotidx(::Type{&lt;:NewBoundaryCondition}, knots::Vector, x)</code></pre><p>Where <code>knots</code> is <code>iter.knots</code> and <code>NewBoundaryCondition</code> is the new boundary conditions. This method is expected to handle values of <code>x</code> that are both inbounds or extrapolated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/iterate.jl#L228-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system" href="#Interpolations.prefiltering_system"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M, b = prefiltering_system{T,TC,GT&lt;:GridType,D&lt;:Degree}m(::T, ::Type{TC}, n::Int, ::Type{D}, ::Type{GT})</code></pre><p>Given element types (<code>T</code>, <code>TC</code>) and interpolation scheme (<code>GT</code>, <code>D</code>) as well the number of rows in the data input (<code>n</code>), compute the system used to prefilter spline coefficients. Boundary conditions determine the values on the first and last rows.</p><p>Some of these boundary conditions require that these rows have off-tridiagonal elements (e.g the <code>[1,3]</code> element of the matrix). To maintain the efficiency of solving tridiagonal systems, the <a href="https://en.wikipedia.org/wiki/Woodbury_matrix_identity">Woodbury matrix identity</a> is used to add additional elements off the main 3 diagonals.</p><p>The filtered coefficients are given by solving the equation system</p><pre><code class="nohighlight hljs">M * c = v + b</code></pre><p>where <code>c</code> are the sought coefficients, and <code>v</code> are the data points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/prefiltering.jl#L132-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{BC}}} where {T, TC, BC&lt;:Union{Flat{OnCell}, Reflect{OnCell}}}" href="#Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{BC}}} where {T, TC, BC&lt;:Union{Flat{OnCell}, Reflect{OnCell}}}"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Quadratic{Flat}</code> <code>OnCell</code> and <code>Quadratic{Reflect}</code> <code>OnCell</code> amounts to setting <code>y_1&#39;(x) = 0</code> at x=1/2. Applying this condition yields</p><pre><code class="nohighlight hljs">-cm + c = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/quadratic.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{BC}}} where {T, TC, BC&lt;:Union{Flat{OnGrid}, Reflect{OnGrid}}}" href="#Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{BC}}} where {T, TC, BC&lt;:Union{Flat{OnGrid}, Reflect{OnGrid}}}"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Quadratic{Flat}</code> <code>OnGrid</code> and <code>Quadratic{Reflect}</code> <code>OnGrid</code> amount to setting <code>y_1&#39;(x) = 0</code> at <code>x=1</code>. Applying this condition yields</p><pre><code class="nohighlight hljs">-cm + cp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/quadratic.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Flat{OnCell}}}} where {T, TC}" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Flat{OnCell}}}} where {T, TC}"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Flat}</code>, <code>OnCell</code> amounts to setting <code>y_1&#39;(x) = 0</code> at <code>x = 1/2</code>. Applying this condition yields</p><pre><code class="nohighlight hljs">-9/8 cm + 11/8 c - 3/8 cp + 1/8 cpp = 0</code></pre><p>or, equivalently,</p><pre><code class="nohighlight hljs">-9 cm + 11 c -3 cp + 1 cpp = 0</code></pre><p>(Note that we use <code>y_1&#39;(x)</code> although it is strictly not valid in this domain; if we were to use <code>y_0&#39;(x)</code> we would have to introduce new coefficients, so that would not close the system. Instead, we extend the outermost polynomial for an extra half-cell.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/cubic.jl#L126-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Flat{OnGrid}}}} where {T, TC}" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Flat{OnGrid}}}} where {T, TC}"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Flat}</code> <code>OnGrid</code> amounts to setting <code>y_1&#39;(x) = 0</code> at <code>x = 1</code>. Applying this condition yields</p><pre><code class="nohighlight hljs">-cm + cp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/cubic.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Line{OnCell}}}} where {T, TC}" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Line{OnCell}}}} where {T, TC}"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Line}</code> <code>OnCell</code> amounts to setting <code>y_1&#39;&#39;(x) = 0</code> at <code>x = 1/2</code>. Applying this condition yields</p><pre><code class="nohighlight hljs">3 cm -7 c + 5 cp -1 cpp = 0</code></pre><p>(Note that we use <code>y_1&#39;(x)</code> although it is strictly not valid in this domain; if we were to use <code>y_0&#39;(x)</code> we would have to introduce new coefficients, so that would not close the system. Instead, we extend the outermost polynomial for an extra half-cell.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/cubic.jl#L159-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Line{OnGrid}}}} where {T, TC}" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Line{OnGrid}}}} where {T, TC}"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Line}</code> <code>OnGrid</code> amounts to setting <code>y_1&#39;&#39;(x) = 0</code> at <code>x = 1</code>. Applying this condition gives:</p><pre><code class="nohighlight hljs">1 cm -2 c + 1 cp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/cubic.jl#L188-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Free}} where {T, TC}" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Free}} where {T, TC}"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Free}</code> <code>OnGrid</code> and <code>Cubic{Free}</code> <code>OnCell</code> amount to requiring an extra continuous derivative at the second-to-last cell boundary; this means <code>y_1&#39;&#39;&#39;(2) = y_2&#39;&#39;&#39;(2)</code>, yielding</p><pre><code class="nohighlight hljs">1 cm -3 c + 3 cp -1 cpp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/cubic.jl#L230-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Periodic}} where {T, TC}" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Periodic}} where {T, TC}"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Periodic}</code> <code>OnGrid</code> closes the system by looking at the coefficients themselves as periodic, yielding</p><pre><code class="nohighlight hljs">c0 = c(N+1)</code></pre><p>where <code>N</code> is the number of data points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/cubic.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Free}} where {T, TC}" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Free}} where {T, TC}"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Quadratic{Free}</code> <code>OnGrid</code> and <code>Quadratic{Free}</code> <code>OnCell</code> amount to requiring an extra continuous derivative at the second-to-last cell boundary; this means that <code>y_1&#39;&#39;(3/2) = y_2&#39;&#39;(3/2)</code>, yielding</p><pre><code class="nohighlight hljs">1 cm -3 c + 3 cp - cpp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/quadratic.jl#L151-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Periodic}} where {T, TC}" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:Periodic}} where {T, TC}"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Quadratic{Periodic}</code> <code>OnGrid</code> and <code>Quadratic{Periodic}</code> <code>OnCell</code> close the system by looking at the coefficients themselves as periodic, yielding</p><pre><code class="nohighlight hljs">c0 = c(N+1)</code></pre><p>where <code>N</code> is the number of data points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/quadratic.jl#L172-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{var&quot;#s65&quot;} where var&quot;#s65&quot;&lt;:Line}} where {T, TC}" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{var&quot;#s65&quot;} where var&quot;#s65&quot;&lt;:Line}} where {T, TC}"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Quadratic{Line}</code> <code>OnGrid</code> and <code>Quadratic{Line}</code> <code>OnCell</code> amount to setting <code>y_1&#39;&#39;(x) = 0</code> at <code>x=1</code> and <code>x=1/2</code> respectively. Since <code>y_i&#39;&#39;(x)</code> is independent of <code>x</code> for a quadratic b-spline, these both yield</p><pre><code class="nohighlight hljs">1 cm -2 c + 1 cp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/quadratic.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.priorknotidx-Union{Tuple{ET}, Tuple{T}, Tuple{Interpolations.KnotIterator{T, ET}, Any}} where {T, ET}" href="#Interpolations.priorknotidx-Union{Tuple{ET}, Tuple{T}, Tuple{Interpolations.KnotIterator{T, ET}, Any}} where {T, ET}"><code>Interpolations.priorknotidx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">priorknotidx(iter::KnotIterator, x)</code></pre><p>Returns the index of the last knot such that <code>k &lt; x</code> or <code>nothing</code> ig not such knot exists.</p><p>New boundary conditions should define</p><pre><code class="nohighlight hljs">priorknotidx(::Type{&lt;:NewBoundaryCondition}, knots::Vector, x)</code></pre><p>Where knots is <code>iter.knots</code> and <code>NewBoundaryCondition</code> is the new boundary condition. This method is expected to handle values of <code>x</code> that are both inbounds or extrapolated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/iterate.jl#L253-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.rescale_gradient" href="#Interpolations.rescale_gradient"><code>Interpolations.rescale_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>rescale_gradient(r::AbstractRange)</code></p><p>Implements the chain rule dy/dx = dy/du * du/dx for use when calculating gradients with scaled interpolation objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/scaling/scaling.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.root_storage_type-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractInterpolation" href="#Interpolations.root_storage_type-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractInterpolation"><code>Interpolations.root_storage_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Interpolations.root_storage_type(::Type{&lt;:AbstractInterpolation}) -&gt; Type{&lt;:AbstractArray}</code></pre><p>This function returns the type of the root coefficients array of an <code>AbstractInterpolation</code>. Some array wrappers, like <code>OffsetArray</code>, should be skipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/gpu_support.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.show_ranged-Tuple{IO, Any, Any}" href="#Interpolations.show_ranged-Tuple{IO, Any, Any}"><code>Interpolations.show_ranged</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show_ranged(io, X, knots)</code></pre><p>A replacement for the default array-<code>show</code> for types that may not have the canonical evaluation points. <code>rngs</code> is the tuple of knots along each axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/io.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.value_weights" href="#Interpolations.value_weights"><code>Interpolations.value_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">w = value_weights(degree, δx)</code></pre><p>Compute the weights for interpolation of the value at an offset <code>δx</code> from the &quot;base&quot; position. <code>degree</code> describes the interpolation scheme.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Interpolations.value_weights(Linear(), 0.2)
(0.8, 0.2)</code></pre><p>This corresponds to the fact that linear interpolation at <code>x + 0.2</code> is <code>0.8*y[x] + 0.2*y[x+1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L315-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.weightedindexes-Union{Tuple{N}, Tuple{F}, Tuple{F, Tuple{Vararg{Interpolations.Flag, N}}, Tuple{Vararg{AbstractVector{T} where T, N}}, Tuple{Vararg{Number, N}}}} where {F, N}" href="#Interpolations.weightedindexes-Union{Tuple{N}, Tuple{F}, Tuple{F, Tuple{Vararg{Interpolations.Flag, N}}, Tuple{Vararg{AbstractVector{T} where T, N}}, Tuple{Vararg{Number, N}}}} where {F, N}"><code>Interpolations.weightedindexes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weightedindexes(fs, itpflags, nodes, xs)</code></pre><p>Compute <code>WeightedIndex</code> values for evaluation at the position <code>xs...</code>. <code>fs</code> is a function or tuple of functions indicating the types of index required, typically <code>value_weights</code>, <code>gradient_weights</code>, and/or <code>hessian_weights</code>. <code>itpflags</code> and <code>nodes</code> can be obtained from <code>itpinfo(itp)...</code>.</p><p>See the &quot;developer documentation&quot; for further information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/indexing.jl#L54-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.BSplineInterpolation" href="#Interpolations.BSplineInterpolation"><code>Interpolations.BSplineInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BSplineInterpolation{T,N,TCoefs,IT,Axs}</code></pre><p>An interpolant-type for b-spline interpolation on a uniform grid with integer nodes. <code>T</code> indicates the element type for operations like <code>collect(itp)</code>, and may also agree with the values obtained from <code>itp(x, y, ...)</code> at least for certain types of <code>x</code> and <code>y</code>. <code>N</code> is the dimensionality of the interpolant. The remaining type-parameters describe the types of fields:</p><ul><li>the <code>coefs</code> field holds the interpolation coefficients. Depending on prefiltering, these may or may not be the same as the supplied array of interpolant values.</li><li><code>parentaxes</code> holds the axes of the parent. Depending on prefiltering this may be &quot;narrower&quot; than the axes of <code>coefs</code>.</li><li><code>it</code> holds the interpolation type, e.g., <code>BSpline(Linear())</code> or <code>(BSpline(Quadratic(OnCell()),BSpline(Linear()))</code>.</li></ul><p><code>BSplineInterpolation</code> objects are typically created with <a href="#Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray, IT, Real, Int64}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline}, N} where N}, BSpline}"><code>interpolate</code></a>. However, for customized control you may also construct them with</p><pre><code class="nohighlight hljs">BSplineInterpolation(TWeights, coefs, it, axs)</code></pre><p>where <code>T</code> gets computed from the product of <code>TWeights</code> and <code>eltype(coefs)</code>. (This is equivalent to indicating that you&#39;ll be evaluating at locations <code>itp(x::TWeights, y::TWeights, ...)</code>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/b-splines/b-splines.jl#L51-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.BoundaryCondition" href="#Interpolations.BoundaryCondition"><code>Interpolations.BoundaryCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition</code></pre><p>An abstract type with one of the following values (see the help for each for details):</p><ul><li><code>Throw(gt)</code></li><li><code>Flat(gt)</code></li><li><code>Line(gt)</code></li><li><code>Free(gt)</code></li><li><code>Periodic(gt)</code></li><li><code>Reflect(gt)</code></li><li><code>InPlace(gt)</code></li><li><code>InPlaceQ(gt)</code></li></ul><p>where <code>gt</code> is the grid type, e.g., <a href="#Interpolations.OnGrid"><code>OnGrid()</code></a> or <a href="#Interpolations.OnCell"><code>OnCell()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L72-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.BoundsCheckStyle" href="#Interpolations.BoundsCheckStyle"><code>Interpolations.BoundsCheckStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoundsCheckStyle(itp)</code></pre><p>A trait to determine dispatch of bounds-checking for <code>itp</code>. Can return <code>NeedsCheck()</code>, in which case bounds-checking is performed, or <code>CheckWillPass()</code> in which case the check will return <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L179-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.GriddedInterpolation-Union{Tuple{IT}, Tuple{TWeights}, Tuple{TCoefs}, Tuple{N}, Tuple{Type{TWeights}, Tuple{Vararg{AbstractUnitRange, N}}, AbstractArray{TCoefs, N}, IT}} where {N, TCoefs, TWeights&lt;:Real, IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded}, N} where N}, Gridded}}" href="#Interpolations.GriddedInterpolation-Union{Tuple{IT}, Tuple{TWeights}, Tuple{TCoefs}, Tuple{N}, Tuple{Type{TWeights}, Tuple{Vararg{AbstractUnitRange, N}}, AbstractArray{TCoefs, N}, IT}} where {N, TCoefs, TWeights&lt;:Real, IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded}, N} where N}, Gridded}}"><code>Interpolations.GriddedInterpolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GriddedInterpolation(typeOfWeights::Type{&lt;:Real},
                     knots::NTuple{N, AbstractUnitRange },
                     array::AbstractArray{TCoefs,N},
                     interpolationType::DimSpec{&lt;:Gridded})

Construct a GriddedInterpolation for generic knots from an AbstractUnitRange.

AbstractUnitRanges are collected to an Array to not confuse bound calculations (See Issue #398)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/gridded/gridded.jl#L50-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.GriddedInterpolation-Union{Tuple{IT}, Tuple{TWeights}, Tuple{Tel}, Tuple{N}, Tuple{Type{TWeights}, Tuple{Vararg{Union{AbstractVector{T}, Tuple} where T, N}}, AbstractArray{Tel, N}, IT}} where {N, Tel, TWeights&lt;:Real, IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded}, N} where N}, Gridded}}" href="#Interpolations.GriddedInterpolation-Union{Tuple{IT}, Tuple{TWeights}, Tuple{Tel}, Tuple{N}, Tuple{Type{TWeights}, Tuple{Vararg{Union{AbstractVector{T}, Tuple} where T, N}}, AbstractArray{Tel, N}, IT}} where {N, Tel, TWeights&lt;:Real, IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded}, N} where N}, Gridded}}"><code>Interpolations.GriddedInterpolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GriddedInterpolation(typeOfWeights::Type{&lt;:Real},
                     knots::NTuple{N, Union{ AbstractVector{T}, Tuple } },
                     array::AbstractArray{Tel,N},
                     interpolationType::DimSpec{&lt;:Gridded})

Construct a GriddedInterpolation for generic knots from an AbstractArray</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/gridded/gridded.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.KnotIterator" href="#Interpolations.KnotIterator"><code>Interpolations.KnotIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KnotIterator{T,ET}(k::AbstractArray{T}, bc::ET)</code></pre><p>Defines an iterator over the knots in <code>k</code> based on the boundary conditions <code>bc</code>.</p><p><strong>Fields</strong></p><ul><li><code>knots::Vector{T}</code> The interpolated knots of the axis to iterate over</li><li><code>bc::ET</code> The Boundary Condition for the axis</li><li><code>nknots::Int</code> The number of interpolated knots (ie. <code>length(knots)</code>)</li></ul><p><code>ET</code> is <code>Union{BoundaryCondition,Tuple{BoundaryCondition,BoundaryCondition}}</code></p><p><strong>Iterator Interface</strong></p><p>The following methods defining Julia&#39;s iterator interface have been defined</p><p><code>IteratorSize(::Type{KnotIterator})</code> -&gt; Will return one of the following</p><ul><li><code>Base.IsInfinite</code> if the iteration will produces an infinite sequence of knots</li><li><code>Base.HasLength</code> if iteration will produce a finite sequence of knots</li><li><code>Base.SizeUnknown</code> if we can&#39;t decided from only the type information</li></ul><p><code>length</code> and <code>size</code> -&gt; Are defined if IteratorSize is HasLength, otherwise will raise a MethodError.</p><p><code>IteratorEltype</code> will always return <code>HasEltype</code>, as we always track the data types of the knots</p><p><code>eltype</code> will return the data type of the knots</p><p><code>iterate</code> Defines iteration over the knots starting from the first one and moving in the forward direction along the axis.</p><p><strong>Knots for Multi-dimensional Interpolants</strong></p><p>Iteration over the knots of a multi-dimensional interpolant is done by wrapping multiple KnotIterator within <code>Iterators.product</code>.</p><p><strong>Indexing</strong></p><p><code>KnotIterator</code> provides limited support for accessing knots via indexing</p><ul><li><code>getindex</code> is provided for <code>KnotIterator</code> but does not support Multidimensional interpolations (As wrapped by <code>ProductIterator</code>) or non-Int indexes.</li><li>A <code>BoundsError</code> will be raised if out of bounds and <code>checkbounds</code> has been implemented for <code>KnotIterator</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; using Interpolations;

julia&gt; etp = linear_interpolation([1.0, 1.2, 2.3, 3.0], rand(4); extrapolation_bc=Periodic());

julia&gt; kiter = knots(etp);

julia&gt; kiter[4]
3.0

julia&gt; kiter[36]
24.3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/iterate.jl#L9-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.KnotRange" href="#Interpolations.KnotRange"><code>Interpolations.KnotRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KnotRange(iter::KnotIterator{T}, start, stop)</code></pre><p>Defines an iterator over a range of knots such that <code>start &lt; k &lt; stop</code>.</p><p><strong>Fields</strong></p><ul><li><code>iter::KnotIterator{T}</code> Underlying <code>KnotIterator</code> providing the knots iterated</li><li><code>range::R</code> Iterator defining the range of knot indices iterated. Where <code>R &lt;: Union{Iterators.Count, UnitRange}</code></li></ul><p><strong>Iterator Interface</strong></p><p>The following methods defining the Julia&#39;s iterator interface have been defined</p><p><code>Base.IteratorSize</code> -&gt; Will return one of the following:</p><ul><li><code>Base.HasLength</code> if <code>range</code> is of finite length</li><li><code>Base.IsInfinite</code> if <code>range</code> is of infinite length</li><li><code>Base.SizeUnknown</code> if the type of <code>range</code> is unspecified</li></ul><p><code>Base.IteratorEltype</code> -&gt; Returns <code>Base.EltypeUnknown</code> if type parameter not provided, otherwise <code>Base.HasEltype</code></p><p><code>length</code> and <code>size</code> -&gt; Returns the number of knots to be iterated if <code>IteratorSize !== IsInfinite</code>, otherwise will raise <code>MethodError</code></p><p><strong>Multidimensional Interpolants</strong></p><p>Iteration over the knots of a multi-dimensional interpolant is done by wrapping multiple <code>KnotRange</code> iterators within <code>Iterators.product</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/iterate.jl#L335-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.LanczosInterpolation" href="#Interpolations.LanczosInterpolation"><code>Interpolations.LanczosInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LanczosInterpolation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/lanczos/lanczos.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.MonotonicInterpolation" href="#Interpolations.MonotonicInterpolation"><code>Interpolations.MonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonotonicInterpolation</code></pre><p>Monotonic interpolation up to third order represented by type, knots and coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/monotonic/monotonic.jl#L121-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.MonotonicInterpolationType" href="#Interpolations.MonotonicInterpolationType"><code>Interpolations.MonotonicInterpolationType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonotonicInterpolationType</code></pre><p>Abstract class for all types of monotonic interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/monotonic/monotonic.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.WeightedIndex" href="#Interpolations.WeightedIndex"><code>Interpolations.WeightedIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">wi = WeightedIndex(indexes, weights)</code></pre><p>Construct a weighted index <code>wi</code>, which can be thought of as a generalization of an ordinary array index to the context of interpolation. For an ordinary vector <code>a</code>, <code>a[i]</code> extracts the element at index <code>i</code>. When interpolating, one is typically interested in a range of indexes and the output is some weighted combination of array values at these indexes. For example, for linear interpolation at a location <code>x</code> between integers <code>i</code> and <code>i+1</code>, we have</p><pre><code class="nohighlight hljs">ret = (1-f)*a[i] + f*a[i+1]</code></pre><p>where <code>f = x-i</code> lies between 0 and 1. This can be represented as <code>a[wi]</code>, where</p><pre><code class="nohighlight hljs">wi = WeightedIndex(i:i+1, (1-f, f))</code></pre><p>i.e.,</p><pre><code class="nohighlight hljs">ret = sum(a[indexes] .* weights)</code></pre><p>Linear interpolation thus constructs weighted indices using a 2-tuple for <code>weights</code> and a length-2 <code>indexes</code> range. Higher-order interpolation would involve more positions and weights (e.g., 3-tuples for quadratic interpolation, 4-tuples for cubic).</p><p>In multiple dimensions, separable interpolation schemes are implemented in terms of multiple weighted indices, accessing <code>A[wi1, wi2, ...]</code> where each <code>wi</code> is the <code>WeightedIndex</code> along the corresponding dimension.</p><p>For value interpolation, <code>weights</code> will typically sum to 1. However, for gradient and Hessian computation this will not necessarily be true. For example, the gradient of one-dimensional linear interpolation can be represented as</p><pre><code class="nohighlight hljs">gwi = WeightedIndex(i:i+1, (-1, 1))
g1 = a[gwi]</code></pre><p>For a three-dimensional array <code>A</code>, one might compute <code>∂A/∂x₂</code> (the second component of the gradient) as <code>A[wi1, gwi2, wi3]</code>, where <code>wi1</code> and <code>wi3</code> are &quot;value&quot; weights and <code>gwi2</code> &quot;gradient&quot; weights.</p><p><code>indexes</code> may be supplied as a range or as a tuple of the same length as <code>weights</code>. The latter is applicable, e.g., for periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/fcb6201b941a0dd5cadf7f10b038f642d8999944/src/Interpolations.jl#L192-L234">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../devdocs/">« Developer documentation</a><a class="docs-footer-nextpage" href="../NEWS/">News and Changes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 3 April 2024 03:48">Wednesday 3 April 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
