var documenterSearchIndex = {"docs":
[{"location":"other_packages/#Other-Interpolation-Packages","page":"Other Interpolation Packages","title":"Other Interpolation Packages","text":"","category":"section"},{"location":"other_packages/","page":"Other Interpolation Packages","title":"Other Interpolation Packages","text":"Other interpolation packages for Julia include:","category":"page"},{"location":"other_packages/","page":"Other Interpolation Packages","title":"Other Interpolation Packages","text":"ApproXD.jl implements B-spline and linear interpolation in Julia.\nBarycentricInterpolation.jl implements the Barycentric formula for polynomial interpolation on equispaced points and Chebyshev points of the first and second kind.\nBasicInterpolators.jl provides a collection of common interpolation recipes for basic applications.\nBSplineKit.jl offers tools for B-spline based Galerkin and collocation methods, including for interpolation and approximation.\nCurves.jl supports log-interpolation via immutable Curve objects.\nDataInterpolations.jl is a library for performing interpolations of one-dimensional data.\nDierckx.jl is a wrapper for the dierckx Fortran library, which also underlies scipy.interpolate.\nDIVAnd.jl for N-dimensional smoothing interpolation. \nFastChebInterp.jl does fast multidimensional Chebyshev interpolation on a hypercube using separable grid of interpolation points.\nFEMBasis.jl contains interpolation routines for standard finite element function spaces.\nFineShift.jl does fast sub-sample shifting of multidimensional arrays.\nFourierTools.jl includes sinc interpolation for up and down sampling.\nGridInterpolations.jl performs multivariate interpolation on a rectilinear grid.\nInterpolationKernels.jl provides a library of interpolation kernels.\nKissSmoothing.jl implements denoising and a Radial Basis Function estimation procedure.\nLinearInterpolations.jl allows for interpolation using weighted averages allowing probability distributions, rotations, and other Lie groups to be interpolated.\nLinearInterpolators.jl provides linear interpolation methods for Julia based on InterpolationKernels.jl, above.\nLocalFunctionApproximation.jl provides local function approximators that interpolates a scalar-valued function across a vector space.\nPCHIPInterpolation.jl for monotonic interpolation.\nPiecewiseLinearApprox.jl performs piecewise linear interpolation over an arbitrary number of dimensions.\nScatteredInterpolation.jl interpolates scattered data in arbitrary dimensions.","category":"page"},{"location":"other_packages/","page":"Other Interpolation Packages","title":"Other Interpolation Packages","text":"Some of these packages support methods that Interpolations does not, so if you can't find what you need here, check one of them or submit a pull request here.","category":"page"},{"location":"other_packages/","page":"Other Interpolation Packages","title":"Other Interpolation Packages","text":"If you would like to list a registered package that is related to interpolation, please create a Github issue.","category":"page"},{"location":"interpolations/#General-usage","page":"General usage","title":"General usage","text":"","category":"section"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"Note: the current version of Interpolations supports interpolation evaluation using index calls [], but this feature will be deprecated in future. We highly recommend function calls with () as follows.","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"Given an AbstractArray A, construct an \"interpolation object\" itp as","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"itp = interpolate(A, options...)","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"where options... (discussed below) controls the type of interpolation you want to perform.  This syntax assumes that the samples in A are equally-spaced.","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"To evaluate the interpolation at position (x, y, ...), simply do","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"v = itp(x, y, ...)","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"Some interpolation objects support computation of the gradient, which can be obtained as","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"g = Interpolations.gradient(itp, x, y, ...)","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"or as","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"Interpolations.gradient!(g, itp, x, y, ...)","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"where g is a pre-allocated vector.","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"Some interpolation objects support computation of the hessian, which can be obtained as","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"h = Interpolations.hessian(itp, x, y, ...)","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"or","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"Interpolations.hessian!(h, itp, x, y, ...)","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"where h is a pre-allocated matrix.","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"A may have any element type that supports the operations of addition and multiplication.  Examples include scalars like Float64, Int, and Rational, but also multi-valued types like RGB color vectors.","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"Positions (x, y, ...) are n-tuples of numbers. Typically these will be real-valued (not necessarily integer-valued), but can also be of types such as DualNumbers if you want to verify the computed value of gradients. (Alternatively, verify gradients using ForwardDiff.) You can also use Julia's iterator objects, e.g.,","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"function ongrid!(dest, itp)\n    for I in CartesianIndices(itp)\n        dest[I] = itp(I)\n    end\nend","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"would store the on-grid value at each grid point of itp in the output dest. Finally, courtesy of Julia's indexing rules, you can also use","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"fine = itp(range(1,stop=10,length=1001), range(1,stop=15,length=201))","category":"page"},{"location":"interpolations/","page":"General usage","title":"General usage","text":"There is also an abbreviated Convenience notation.","category":"page"},{"location":"NEWS/","page":"News and Changes","title":"News and Changes","text":"For a comprehensive list of changes, see Releases.","category":"page"},{"location":"NEWS/#v0.14.0","page":"News and Changes","title":"v0.14.0","text":"","category":"section"},{"location":"NEWS/","page":"News and Changes","title":"News and Changes","text":"Breaking changes:","category":"page"},{"location":"NEWS/#Implement-inplace-GriddedInterpolation-([#496](https://github.com/JuliaMath/Interpolations.jl/pull/496),-for-[#495](https://github.com/JuliaMath/Interpolations.jl/issues/495))","page":"News and Changes","title":"Implement inplace GriddedInterpolation (#496, for #495)","text":"","category":"section"},{"location":"NEWS/","page":"News and Changes","title":"News and Changes","text":"interpolate now copies the coefficients for GriddedInterpolation.\ninterpolate! now does not copy the coefficients for GriddedInterpolation.\nThe third argument of GriddedInterpolation describes the array type of the coefficients rather than the element type of Array.","category":"page"},{"location":"NEWS/#v0.9.0","page":"News and Changes","title":"v0.9.0","text":"","category":"section"},{"location":"NEWS/","page":"News and Changes","title":"News and Changes","text":"Breaking changes:","category":"page"},{"location":"NEWS/","page":"News and Changes","title":"News and Changes","text":"gradient and hessian are no longer exported; use Interpolations.gradient and Interpolations.hessian.\ninterpolate objects now check bounds, and throw an error if you try to evaluate them at locations beyond the edge of their interpolation domain; use extrapolate if you need out-of-bounds evaluation\nFor quadratic and cubic interpolation, interpolate! now returns an object whose axes are narrowed by the amount of padding needed on the array edges. This preserves correspondence between input indices and output indices. See https://julialang.org/blog/2017/04/offset-arrays for more information.\nThe parametrization of some types has changed; this does not affect users of the \"exported\" interface, but does break packages that performed manual construction of explicit types.","category":"page"},{"location":"NEWS/","page":"News and Changes","title":"News and Changes","text":"Changes with deprecation warnings:","category":"page"},{"location":"NEWS/","page":"News and Changes","title":"News and Changes","text":"itp[i...] should be replaced with itp(i...).\nOnGrid and OnCell should now be placed inside the boundary condition (e.g., Flat(OnGrid())), and should only be used for quadratic and cubic interpolation.\nthe extrapolation boundary condition Linear was changed to Line, to be consistent with interpolation boundary conditions.","category":"page"},{"location":"NEWS/","page":"News and Changes","title":"News and Changes","text":"Advance notice of future changes:","category":"page"},{"location":"NEWS/","page":"News and Changes","title":"News and Changes","text":"In future versions itp[i...] may be interpreted with reference to the parent array's indices rather than the knots supplied by the user (relevant for scale and Gridded). If you fix the existing deprecation warnings then you should be prepared for this change.","category":"page"},{"location":"convenience-construction/#Convenience-notation","page":"Convenience Constructors","title":"Convenience notation","text":"","category":"section"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"For constant, linear, and cubic spline interpolations, constant_interpolation, linear_interpolation, and cubic_spline_interpolation can be used to create interpolating and extrapolating objects handily.","category":"page"},{"location":"convenience-construction/#Motivating-Example","page":"Convenience Constructors","title":"Motivating Example","text":"","category":"section"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"By using the convenience constructor one can simplify expressions. For example, the creation of an interpolation object","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"extrap_full = extrapolate(scale(interpolate(A, BSpline(Linear())), xs), Line())","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"can be written as the more readable","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"extrap = linear_interpolation(xs, A, extrapolation_bc = Line())","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"by using the convenience constructor.","category":"page"},{"location":"convenience-construction/#Usage","page":"Convenience Constructors","title":"Usage","text":"","category":"section"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"f(x) = log(x)\nxs = 1:0.2:5\nA = [f(x) for x in xs]\n\n# linear interpolation\ninterp_linear = linear_interpolation(xs, A)\ninterp_linear(3) # exactly log(3)\ninterp_linear(3.1) # approximately log(3.1)\n\n# cubic spline interpolation\ninterp_cubic = cubic_spline_interpolation(xs, A)\ninterp_cubic(3) # exactly log(3)\ninterp_cubic(3.1) # approximately log(3.1)","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"which support multidimensional data as well:","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"f(x,y) = log(x+y)\nxs = 1:0.2:5\nys = 2:0.1:5\nA = [f(x,y) for x in xs, y in ys]\n\n# linear interpolation\ninterp_linear = linear_interpolation((xs, ys), A)\ninterp_linear(3, 2) # exactly log(3 + 2)\ninterp_linear(3.1, 2.1) # approximately log(3.1 + 2.1)\n\n# cubic spline interpolation\ninterp_cubic = cubic_spline_interpolation((xs, ys), A)\ninterp_cubic(3, 2) # exactly log(3 + 2)\ninterp_cubic(3.1, 2.1) # approximately log(3.1 + 2.1)","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"For extrapolation, i.e., when interpolation objects are evaluated in coordinates outside the range provided in constructors, the default option for a boundary condition is Throw so that they will return an error. Interested users can specify boundary conditions by providing an extra parameter for extrapolation_bc:","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"f(x) = log(x)\nxs = 1:0.2:5\nA = [f(x) for x in xs]\n\n# extrapolation with linear boundary conditions\nextrap = linear_interpolation(xs, A, extrapolation_bc = Line())\n\n@test extrap(1 - 0.2) # ≈ f(1) - (f(1.2) - f(1))\n@test extrap(5 + 0.2) # ≈ f(5) + (f(5) - f(4.8))","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"You can also use a \"fill\" value, which gets returned whenever you ask for out-of-range values:","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"extrap = linear_interpolation(xs, A, extrapolation_bc = NaN)\n@test isnan(extrap(5.2))","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"Irregular grids are supported as well; note that presently only constant_interpolation and linear_interpolation supports irregular grids.","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"xs = [x^2 for x = 1:0.2:5]\nA = [f(x) for x in xs]\n\n# linear interpolation\ninterp_linear = linear_interpolation(xs, A)\ninterp_linear(1) # exactly log(1)\ninterp_linear(1.05) # approximately log(1.05)","category":"page"},{"location":"convenience-construction/#Example-with-Plots.jl","page":"Convenience Constructors","title":"Example with Plots.jl","text":"","category":"section"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"An interpolated object is also easily capable of being plotted with Plots.jl. A simple example is as follows:","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"using Interpolations, Plots\n\n# Lower and higher bound of interval\na = 1.0\nb = 10.0\n# Interval definition\nx = a:1.0:b\n# This can be any sort of array data, as long as\n# length(x) == length(y)\ny = @. cos(x^2 / 9.0) # Function application by broadcasting\n# Interpolations\nitp_linear = linear_interpolation(x, y)\nitp_cubic = cubic_spline_interpolation(x, y)\n# Interpolation functions\nf_linear(x) = itp_linear(x)\nf_cubic(x) = itp_cubic(x)\n# Plots\nwidth, height = 1500, 800 # not strictly necessary\nx_new = a:0.1:b # smoother interval, necessary for cubic spline\n\nscatter(x, y, markersize=10,label=\"Data points\")\nplot!(f_linear, x_new, w=3,label=\"Linear interpolation\")\nplot!(f_cubic, x_new, linestyle=:dash, w=3, label=\"Cubic Spline interpolation\")\nplot!(size = (width, height))\nplot!(legend = :bottomleft)","category":"page"},{"location":"convenience-construction/","page":"Convenience Constructors","title":"Convenience Constructors","text":"And the generated plot is: (Image: interpolation plot example)","category":"page"},{"location":"api/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Library","title":"Library","text":"DocTestSetup= quote\nusing Interpolations\nend","category":"page"},{"location":"api/","page":"Library","title":"Library","text":"Modules = [Interpolations]\nPrivate = false\nOrder = [:function, :type]","category":"page"},{"location":"api/#ChainRulesCore.rrule-Tuple{AbstractInterpolation, Vararg{Any, N} where N}","page":"Library","title":"ChainRulesCore.rrule","text":"ChainRulesCore.rrule(itp::AbstractInterpolation, x...)\n\nChainRulesCore.jl rrule for integration with automatic differentiation libraries. Note that it gives the gradient only with respect to the evaluation point x, and not the data inside itp.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.bounds-Tuple{AbstractInterpolation}","page":"Library","title":"Interpolations.bounds","text":"bounds(itp::AbstractInterpolation)\n\nReturn the bounds of the domain of itp as a tuple of (min, max) pairs for each coordinate. This is best explained by example:\n\njulia> itp = interpolate([1 2 3; 4 5 6], BSpline(Linear()));\n\njulia> bounds(itp)\n((1, 2), (1, 3))\n\njulia> data = 1:3;\n\njulia> knots = ([10, 11, 13.5],);\n\njulia> itp = interpolate(knots, data, Gridded(Linear()));\n\njulia> bounds(itp)\n((10.0, 13.5),)\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.constant_interpolation","page":"Library","title":"Interpolations.constant_interpolation","text":"etp = constant_interpolation(knots, A; extrapolation_bc=Throw())\n\nA shorthand for extrapolate(interpolate(knots, A, scheme), extrapolation_bc), where scheme is either BSpline(Constant()) or Gridded(Constant()) depending on whether knots are ranges or vectors.\n\nConsider using interpolate or extrapolate explicitly as needed rather than using this convenience constructor. Performance will improve without extrapolation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.cubic_spline_interpolation","page":"Library","title":"Interpolations.cubic_spline_interpolation","text":"etp = cubic_spline_interpolation(knots, A; bc=Line(OnGrid()), extrapolation_bc=Throw())\n\nA shorthand for extrapolate(scale(interpolate(A, BSpline(Cubic(bc))),knots), extrapolation_bc).\n\nConsider using interpolate, scale, or extrapolate explicitly as needed rather than using this convenience constructor. Performance will improve without scaling or extrapolation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.extrapolate-Union{Tuple{ET}, Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T, N, IT}, ET}} where {T, N, IT, ET<:Union{Tuple{Vararg{Union{Tuple{Interpolations.BoundaryCondition, Interpolations.BoundaryCondition}, Interpolations.BoundaryCondition}, N} where N}, Interpolations.BoundaryCondition}}","page":"Library","title":"Interpolations.extrapolate","text":"extrapolate(itp, scheme) adds extrapolation behavior to an interpolation object, according to the provided scheme.\n\nThe scheme can take any of these values:\n\nThrow - throws a BoundsError for out-of-bounds indices\nFlat - for constant extrapolation, taking the closest in-bounds value\nLine - linear extrapolation (the wrapped interpolation object must support gradient)\nReflect - reflecting extrapolation (indices must support mod)\nPeriodic - periodic extrapolation (indices must support mod)\n\nYou can also combine schemes in tuples. For example, the scheme (Line(), Flat()) will use linear extrapolation in the first dimension, and constant in the second.\n\nFinally, you can specify different extrapolation behavior in different direction. ((Line(),Flat()), Flat()) will extrapolate linearly in the first dimension if the index is too small, but use constant etrapolation if it is too large, and always use constant extrapolation in the second dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.extrapolate-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T, N, IT}, Any}} where {T, N, IT}","page":"Library","title":"Interpolations.extrapolate","text":"extrapolate(itp, fillvalue) creates an extrapolation object that returns the fillvalue any time the indexes in itp(x1,x2,...) are out-of-bounds.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.interpolate!-Union{Tuple{IT}, Tuple{TWeights}, Tuple{Type{TWeights}, AbstractArray, IT}} where {TWeights, IT<:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline}, N} where N}, BSpline}}","page":"Library","title":"Interpolations.interpolate!","text":"In-place version of interpolate. It destroys input A and may trim the domain at the endpoints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray, IT, Real, Int64}} where IT<:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline}, N} where N}, BSpline}","page":"Library","title":"Interpolations.interpolate","text":"itp = interpolate(A, interpmode, gridstyle, λ, k)\n\nInterpolate an array A in the mode determined by interpmode and gridstyle with regularization following [1], of order k and constant λ.  interpmode may be one of\n\nBSpline(NoInterp())\nBSpline(Linear())\nBSpline(Quadratic(BC())) (see BoundaryCondition)\nBSpline(Cubic(BC()))\n\nIt may also be a tuple of such values, if you want to use different interpolation schemes along each axis.\n\ngridstyle should be one of OnGrid() or OnCell().\n\nk corresponds to the derivative to penalize. In the limit λ->∞, the interpolation function is a polynomial of order k-1. A value of 2 is the most common.\n\nλ is non-negative. If its value is zero, it falls back to non-regularized interpolation.\n\n[1] https://projecteuclid.org/euclid.ss/1038425655.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray, IT}} where IT<:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline}, N} where N}, BSpline}","page":"Library","title":"Interpolations.interpolate","text":"itp = interpolate(A, interpmode)\n\nInterpolate an array A in the mode determined by interpmode. interpmode may be one of\n\nNoInterp()\nBSpline(Constant())\nBSpline(Linear())\nBSpline(Quadratic(bc)) (see BoundaryCondition)\nBSpline(Cubic(bc))\n\nIt may also be a tuple of such values, if you want to use different interpolation schemes along each axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.interpolate-Union{Tuple{IT}, Tuple{N}, Tuple{Tel}, Tuple{Tuple{Vararg{Union{AbstractVector{T}, Tuple} where T, N}}, AbstractArray{Tel, N}, IT}} where {Tel, N, IT<:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded}, N} where N}, Gridded}}","page":"Library","title":"Interpolations.interpolate","text":"itp = interpolate((nodes1, nodes2, ...), A, interpmode)\n\nInterpolate an array A on a non-uniform but rectangular grid specified by the given nodes, in the mode determined by interpmode.\n\ninterpmode may be one of\n\nNoInterp()\nGridded(Constant())\nGridded(Linear())\n\nIt may also be a tuple of such values, if you want to use different interpolation schemes along each axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.knots-Tuple{AbstractInterpolation}","page":"Library","title":"Interpolations.knots","text":"knots(itp::AbstractInterpolation)\nknots(etp::AbstractExtrapolation)\n\nReturns an iterator over knot locations for an AbstractInterpolation or AbstractExtrapolation.\n\nIterator will yield scalar values for interpolations over a single dimension, and tuples of coordinates for higher dimension interpolations. Iteration over higher dimensions is taken as the product of knots along each dimension.\n\nie. Iterator.product(knots on first dim, knots on 2nd dim,...)\n\nExtrapolations with Periodic or Reflect boundary conditions, will produce an infinite sequence of knots.\n\nExample\n\njulia> using Interpolations;\n\njulia> etp = linear_interpolation([1.0, 1.2, 2.3, 3.0], rand(4); extrapolation_bc=Periodic());\n\njulia> Iterators.take(knots(etp), 5) |> collect\n5-element Vector{Float64}:\n 1.0\n 1.2\n 2.3\n 3.0\n 3.2\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.knotsbetween-Tuple{Any}","page":"Library","title":"Interpolations.knotsbetween","text":"knotsbetween(iter; start, stop)\nknotsbetween(iter, start, stop)\n\nIterate over all knots of iter such that start < k < stop.\n\niter can be an AbstractInterpolation, or the output of knots (ie. a KnotIterator or ProductIterator wrapping KnotIterator)\n\nIf start is not provided, iteration will start from the first knot. An ArgumentError will be raised if both start and stop are not provided.\n\nIf no such knots exists will return a KnotIterator with length 0\n\nExample\n\njulia> using Interpolations;\n\njulia> etp = linear_interpolation([1.0, 1.2, 2.3, 3.0], rand(4); extrapolation_bc=Periodic());\n\njulia> knotsbetween(etp; start=38, stop=42) |> collect\n6-element Vector{Float64}:\n 38.3\n 39.0\n 39.2\n 40.3\n 41.0\n 41.2\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.linear_interpolation","page":"Library","title":"Interpolations.linear_interpolation","text":"etp = linear_interpolation(knots, A; extrapolation_bc=Throw())\n\nA shorthand for one of the following.\n\nextrapolate(scale(interpolate(A, BSpline(Linear())), knots), extrapolation_bc)\nextrapolate(interpolate(knots, A, Gridded(Linear())), extrapolation_bc),\n\ndepending on whether knots are ranges or vectors.\n\nConsider using interpolate, scale, or extrapolate explicitly as needed rather than using this convenience constructor. Performance will improve without scaling or extrapolation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.scale-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T, N, IT}, Vararg{AbstractRange, N}}} where {T, N, IT}","page":"Library","title":"Interpolations.scale","text":"scale(itp, xs, ys, ...) scales an existing interpolation object to allow for indexing using other coordinate axes than unit ranges, by wrapping the interpolation object and transforming the indices from the provided axes onto unit ranges upon indexing.\n\nThe parameters xs etc must be either ranges or linspaces, and there must be one coordinate range/linspace for each dimension of the interpolation object.\n\nFor every NoInterp dimension of the interpolation object, the range must be exactly 1:size(itp, d).\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.AkimaMonotonicInterpolation","page":"Library","title":"Interpolations.AkimaMonotonicInterpolation","text":"AkimaMonotonicInterpolation\n\nMonotonic interpolation based on Akima (1970), \"A New Method of Interpolation and Smooth Curve Fitting Based on Local Procedures\", doi:10.1145/321607.321609.\n\nTangents are determined at each given point locally, results are close to manual drawn curves\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.BSpline","page":"Library","title":"Interpolations.BSpline","text":"BSpline(degree)\n\nA flag signaling BSpline (integer-grid b-spline) interpolation along the corresponding axis. degree is one of Constant, Linear, Quadratic, or Cubic.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.CardinalMonotonicInterpolation","page":"Library","title":"Interpolations.CardinalMonotonicInterpolation","text":"CardinalMonotonicInterpolation(tension)\n\nCubic cardinal splines, uses tension parameter which must be between [0,1] Cubin cardinal splines can overshoot for non-monotonic data (increasing tension reduces overshoot).\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Constant","page":"Library","title":"Interpolations.Constant","text":"Constant b-splines are nearest-neighbor interpolations, and effectively return A[round(Int,x)] when interpolating without scaling. Scaling can lead to inaccurate position of the neighbors due to limited numerical precision.\n\nConstant{Previous} interpolates to the previous value and is thus equivalent to A[floor(Int,x)] without scaling. Constant{Next} interpolates to the next value and is thus equivalent to A[ceil(Int,x)] without scaling.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Cubic","page":"Library","title":"Interpolations.Cubic","text":"Cubic(bc::BoundaryCondition)\n\nIndicate that the corresponding axis should use cubic interpolation.\n\nExtended help\n\nAssuming uniform knots with spacing 1, the ith piece of cubic spline implemented here is defined as follows.\n\ny_i(x) = cm p(x-i) + c q(x-i) + cp q(1- (x-i)) + cpp p(1 - (x-i))\n\nwhere\n\np(δx) = 1/6 * (1-δx)^3\nq(δx) = 2/3 - δx^2 + 1/2 δx^3\n\nand the values cX for X ∈ {m, _, p, pp} are the pre-filtered coefficients.\n\nFor future reference, this expands out to the following polynomial:\n\ny_i(x) = 1/6 cm (1+i-x)^3 + c (2/3 - (x-i)^2 + 1/2 (x-i)^3) +\n         cp (2/3 - (1+i-x)^2 + 1/2 (1+i-x)^3) + 1/6 cpp (x-i)^3\n\nWhen we derive boundary conditions we will use derivatives y_0'(x) and y_0''(x)\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.CubicHermite","page":"Library","title":"Interpolations.CubicHermite","text":" CubicHermite\n\nThis type is purposely left undocumented since the interface is expected to radically change in order to make it conform to the AbstractInterpolation interface. Consider this API to be highly unstable and non-public, and that breaking changes to this code could be made in a point release.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.FiniteDifferenceMonotonicInterpolation","page":"Library","title":"Interpolations.FiniteDifferenceMonotonicInterpolation","text":"FiniteDifferenceMonotonicInterpolation\n\nClassic cubic interpolation, no tension parameter. Finite difference can overshoot for non-monotonic data.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Flat","page":"Library","title":"Interpolations.Flat","text":"Flat(gt) sets the extrapolation slope to zero\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Free","page":"Library","title":"Interpolations.Free","text":"Free(gt) the free boundary condition makes sure the interpoland has a continuous third derivative at the second-to-outermost cell boundary\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.FritschButlandMonotonicInterpolation","page":"Library","title":"Interpolations.FritschButlandMonotonicInterpolation","text":"FritschButlandMonotonicInterpolation\n\nMonotonic interpolation based on  Fritsch & Butland (1984), \"A Method for Constructing Local Monotone Piecewise Cubic Interpolants\", doi:10.1137/0905021.\n\nFaster than FritschCarlsonMonotonicInterpolation (only requires one pass) but somewhat higher apparent \"tension\".\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.FritschCarlsonMonotonicInterpolation","page":"Library","title":"Interpolations.FritschCarlsonMonotonicInterpolation","text":"FritschCarlsonMonotonicInterpolation\n\nMonotonic interpolation based on Fritsch & Carlson (1980), \"Monotone Piecewise Cubic Interpolation\", doi:10.1137/0717021.\n\nTangents are first initialized, then adjusted if they are not monotonic can overshoot for non-monotonic data\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.InPlace","page":"Library","title":"Interpolations.InPlace","text":"InPlace(gt) is a boundary condition that allows prefiltering to occur in-place (it typically requires padding)\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.InPlaceQ","page":"Library","title":"Interpolations.InPlaceQ","text":"InPlaceQ(gt) is similar to InPlace(gt), but is exact when the values being interpolated arise from an underlying quadratic. It is primarily useful for testing purposes, allowing near-exact (to machine precision) comparisons against ground truth.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Lanczos","page":"Library","title":"Interpolations.Lanczos","text":"Lanczos{N}(a=4)\n\nLanczos resampling via a kernel with scale parameter a and support over N neighbors.\n\nThis form of interpolation is merely the discrete convolution of the samples with a Lanczos kernel of size a. The size is directly related to how \"far\" the interpolation will reach for information, and has O(N^2) impact on runtime. An alternative implementation matching lanczos4 from OpenCV is available as Lanczos4OpenCV.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Lanczos4OpenCV","page":"Library","title":"Interpolations.Lanczos4OpenCV","text":"Lanczos4OpenCV()\n\nAlternative implementation of Lanczos resampling using algorithm lanczos4 function of OpenCV: https://github.com/opencv/opencv/blob/de15636724967faf62c2d1bce26f4335e4b359e5/modules/imgproc/src/resize.cpp#L917-L946\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Line","page":"Library","title":"Interpolations.Line","text":"Line(gt) uses a constant slope for extrapolation\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Linear","page":"Library","title":"Interpolations.Linear","text":"Linear()\n\nIndicate that the corresponding axis should use linear interpolation.\n\nExtended help\n\nAssuming uniform knots with spacing 1, the ith piece of linear b-spline implemented here is defined as follows.\n\ny_i(x) = c p(x) + cp p(1-x)\n\nwhere\n\np(δx) = x\n\nand the values cX for X ∈ {_, p} are the coefficients.\n\nLinear b-splines are naturally interpolating, and require no prefiltering; there is therefore no need for boundary conditions to be provided.\n\nAlso, although the implementation is slightly different in order to re-use the framework built for general b-splines, the resulting interpolant is just a piecewise linear function connecting each pair of neighboring data points.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.LinearMonotonicInterpolation","page":"Library","title":"Interpolations.LinearMonotonicInterpolation","text":"LinearMonotonicInterpolation\n\nSimple linear interpolation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Nearest","page":"Library","title":"Interpolations.Nearest","text":"Default parameter for Constant that performs nearest-neighbor interpolation. Can optionally be specified as\n\nConstant() === Constant{Nearest}()\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Next","page":"Library","title":"Interpolations.Next","text":"Parameter for Constant that performs next-neighbor interpolations. Applied through \n\nConstant{Next}()\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.NoInterp","page":"Library","title":"Interpolations.NoInterp","text":"NoInterp() indicates that the corresponding axis must use integer indexing (no interpolation is to be performed)\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.OnCell","page":"Library","title":"Interpolations.OnCell","text":"OnCell() indicates that the boundary condition applies a half-gridspacing beyond the first & last nodes\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.OnGrid","page":"Library","title":"Interpolations.OnGrid","text":"OnGrid() indicates that the boundary condition applies at the first & last nodes\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Periodic","page":"Library","title":"Interpolations.Periodic","text":"Periodic(gt) applies periodic boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Previous","page":"Library","title":"Interpolations.Previous","text":"Parameter for Constant that performs previous-neighbor interpolations. Applied through  ´´´ Constant{Previous}() ´´´\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Quadratic","page":"Library","title":"Interpolations.Quadratic","text":"Quadratic(bc::BoundaryCondition)\n\nIndicate that the corresponding axis should use quadratic interpolation.\n\nExtended help\n\nAssuming uniform knots with spacing 1, the ith piece of quadratic spline implemented here is defined as follows:\n\ny_i(x) = cm p(x-i) + c q(x) + cp p(1-(x-i))\n\nwhere\n\np(δx) = (δx - 1)^2 / 2\nq(δx) = 3/4 - δx^2\n\nand the values for cX for X ∈ {m,_,p} are the pre-filtered coefficients.\n\nFor future reference, this expands to the following polynomial:\n\ny_i(x) = cm * 1/2 * (x-i-1)^2 + c * (3/4 - x + i)^2 + cp * 1/2 * (x-i)^2\n\nWhen we derive boundary conditions we will use derivatives y_1'(x-1) and y_1''(x-1)\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Reflect","page":"Library","title":"Interpolations.Reflect","text":"Reflect(gt) applies reflective boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.SteffenMonotonicInterpolation","page":"Library","title":"Interpolations.SteffenMonotonicInterpolation","text":"SteffenMonotonicInterpolation\n\nMonotonic interpolation based on Steffen (1990), \"A Simple Method for Monotonic Interpolation in One Dimension\", http://adsabs.harvard.edu/abs/1990A%26A...239..443S\n\nOnly one pass, results usually between FritschCarlson and FritschButland.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Throw","page":"Library","title":"Interpolations.Throw","text":"Throw(gt) causes beyond-the-edge extrapolation to throw an error\n\n\n\n\n\n","category":"type"},{"location":"api/#Internal-API","page":"Library","title":"Internal API","text":"","category":"section"},{"location":"api/","page":"Library","title":"Library","text":"Modules = [Interpolations]\nPublic = false\nOrder = [:function, :type]","category":"page"},{"location":"api/#Interpolations.boundstep","page":"Library","title":"Interpolations.boundstep","text":"Returns half the width of one step of the range.\n\nThis function is used to calculate the upper and lower bounds of OnCell interpolation objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.count_interp_dims-Union{Tuple{Type{ITP}}, Tuple{ITP}} where ITP<:AbstractInterpolation","page":"Library","title":"Interpolations.count_interp_dims","text":"n = count_interp_dims(ITP)\n\nCount the number of dimensions along which type ITP is interpolating. NoInterp dimensions do not contribute to the sum.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.deduplicate_knots!-Tuple{Any}","page":"Library","title":"Interpolations.deduplicate_knots!","text":"Interpolations.deduplicate_knots!(knots; move_knots = false)\n\nMakes knots unique by incrementing repeated but otherwise sorted knots using `nextfloat`.\nIf keyword `move_knots` is true, then `nextfloat` will be applied successively until knots\nare unique. Otherwise, a warning will be issued.\n\n# Example\n\n```jldoctest\njulia> knots = [-8.0, 0.0, 20.0, 20.0]\n4-element Vector{Float64}:\n-8.0\n0.0\n20.0\n20.0\n\njulia> Interpolations.deduplicate_knots!(knots)\n4-element Vector{Float64}:\n-8.0\n0.0\n20.0\n20.000000000000004\n\njulia> Interpolations.deduplicate_knots!([1.0, 1.0, 1.0, nextfloat(1.0), nextfloat(1.0)]; move_knots = true)\n5-element Vector{Float64}:\n1.0\n1.0000000000000002\n1.0000000000000004\n1.0000000000000007\n1.0000000000000009\n```\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.gradient_weights","page":"Library","title":"Interpolations.gradient_weights","text":"w = gradient_weights(degree, δx)\n\nCompute the weights for interpolation of the gradient at an offset δx from the \"base\" position. degree describes the interpolation scheme.\n\nExample\n\njulia> Interpolations.gradient_weights(Linear(), 0.2)\n(-1.0, 1.0)\n\nThis defines the gradient of a linear interpolation at 3.2 as y[4] - y[3].\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.hessian_weights","page":"Library","title":"Interpolations.hessian_weights","text":"w = hessian_weights(degree, δx)\n\nCompute the weights for interpolation of the hessian at an offset δx from the \"base\" position. degree describes the interpolation scheme.\n\nExample\n\njulia> Interpolations.hessian_weights(Linear(), 0.2)\n(0.0, 0.0)\n\nLinear interpolation uses straight line segments, so the second derivative is zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.inner_system_diags","page":"Library","title":"Interpolations.inner_system_diags","text":"dl, d, du = inner_system_diags{T,IT}(::Type{T}, n::Int, ::Type{IT})\n\nHelper function to generate the prefiltering equation system: generates the diagonals for a n-by-n tridiagonal matrix with eltype T corresponding to the interpolation type IT.\n\ndl, d, and du are intended to be used e.g. as in M = Tridiagonal(dl, d, du)\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.inner_system_diags-Union{Tuple{T}, Tuple{Type{T}, Int64, Cubic}} where T","page":"Library","title":"Interpolations.inner_system_diags","text":"Cubic: continuity in function value, first and second derivatives yields\n\n2/3 1/6\n1/6 2/3 1/6\n    1/6 2/3 1/6\n       ⋱  ⋱   ⋱\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.lanczos-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Any}} where T","page":"Library","title":"Interpolations.lanczos","text":"lanczos(x, a, n=a)\n\nImplementation of the Lanczos kernel\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.nextknotidx-Union{Tuple{ET}, Tuple{T}, Tuple{Interpolations.KnotIterator{T, ET}, Any}} where {T, ET}","page":"Library","title":"Interpolations.nextknotidx","text":"nextknotidx(iter::KnotIterator, x)\n\nReturns the index of the first knot such that x < k or nothing if no such knot exists.\n\nNew boundary conditions should define:\n\nnextknotidx(::Type{<:NewBoundaryCondition}, knots::Vector, x)\n\nWhere knots is iter.knots and NewBoundaryCondition is the new boundary conditions. This method is expected to handle values of x that are both inbounds or extrapolated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system","page":"Library","title":"Interpolations.prefiltering_system","text":"M, b = prefiltering_system{T,TC,GT<:GridType,D<:Degree}m(::T, ::Type{TC}, n::Int, ::Type{D}, ::Type{GT})\n\nGiven element types (T, TC) and interpolation scheme (GT, D) as well the number of rows in the data input (n), compute the system used to prefilter spline coefficients. Boundary conditions determine the values on the first and last rows.\n\nSome of these boundary conditions require that these rows have off-tridiagonal elements (e.g the [1,3] element of the matrix). To maintain the efficiency of solving tridiagonal systems, the Woodbury matrix identity is used to add additional elements off the main 3 diagonals.\n\nThe filtered coefficients are given by solving the equation system\n\nM * c = v + b\n\nwhere c are the sought coefficients, and v are the data points.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{BC}}} where {T, TC, BC<:Union{Flat{OnCell}, Reflect{OnCell}}}","page":"Library","title":"Interpolations.prefiltering_system","text":"Quadratic{Flat} OnCell and Quadratic{Reflect} OnCell amounts to setting y_1'(x) = 0 at x=1/2. Applying this condition yields\n\n-cm + c = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{BC}}} where {T, TC, BC<:Union{Flat{OnGrid}, Reflect{OnGrid}}}","page":"Library","title":"Interpolations.prefiltering_system","text":"Quadratic{Flat} OnGrid and Quadratic{Reflect} OnGrid amount to setting y_1'(x) = 0 at x=1. Applying this condition yields\n\n-cm + cp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Flat{OnCell}}}} where {T, TC}","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Flat}, OnCell amounts to setting y_1'(x) = 0 at x = 1/2. Applying this condition yields\n\n-9/8 cm + 11/8 c - 3/8 cp + 1/8 cpp = 0\n\nor, equivalently,\n\n-9 cm + 11 c -3 cp + 1 cpp = 0\n\n(Note that we use y_1'(x) although it is strictly not valid in this domain; if we were to use y_0'(x) we would have to introduce new coefficients, so that would not close the system. Instead, we extend the outermost polynomial for an extra half-cell.)\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Flat{OnGrid}}}} where {T, TC}","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Flat} OnGrid amounts to setting y_1'(x) = 0 at x = 1. Applying this condition yields\n\n-cm + cp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Line{OnCell}}}} where {T, TC}","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Line} OnCell amounts to setting y_1''(x) = 0 at x = 1/2. Applying this condition yields\n\n3 cm -7 c + 5 cp -1 cpp = 0\n\n(Note that we use y_1'(x) although it is strictly not valid in this domain; if we were to use y_0'(x) we would have to introduce new coefficients, so that would not close the system. Instead, we extend the outermost polynomial for an extra half-cell.)\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{Line{OnGrid}}}} where {T, TC}","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Line} OnGrid amounts to setting y_1''(x) = 0 at x = 1. Applying this condition gives:\n\n1 cm -2 c + 1 cp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{var\"#s10\"} where var\"#s10\"<:Free}} where {T, TC}","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Free} OnGrid and Cubic{Free} OnCell amount to requiring an extra continuous derivative at the second-to-last cell boundary; this means y_1'''(2) = y_2'''(2), yielding\n\n1 cm -3 c + 3 cp -1 cpp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Cubic{var\"#s10\"} where var\"#s10\"<:Periodic}} where {T, TC}","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Periodic} OnGrid closes the system by looking at the coefficients themselves as periodic, yielding\n\nc0 = c(N+1)\n\nwhere N is the number of data points.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{var\"#s10\"} where var\"#s10\"<:Free}} where {T, TC}","page":"Library","title":"Interpolations.prefiltering_system","text":"Quadratic{Free} OnGrid and Quadratic{Free} OnCell amount to requiring an extra continuous derivative at the second-to-last cell boundary; this means that y_1''(3/2) = y_2''(3/2), yielding\n\n1 cm -3 c + 3 cp - cpp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{var\"#s10\"} where var\"#s10\"<:Periodic}} where {T, TC}","page":"Library","title":"Interpolations.prefiltering_system","text":"Quadratic{Periodic} OnGrid and Quadratic{Periodic} OnCell close the system by looking at the coefficients themselves as periodic, yielding\n\nc0 = c(N+1)\n\nwhere N is the number of data points.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T}, Type{TC}, Int64, Quadratic{var\"#s63\"} where var\"#s63\"<:Line}} where {T, TC}","page":"Library","title":"Interpolations.prefiltering_system","text":"Quadratic{Line} OnGrid and Quadratic{Line} OnCell amount to setting y_1''(x) = 0 at x=1 and x=1/2 respectively. Since y_i''(x) is independent of x for a quadratic b-spline, these both yield\n\n1 cm -2 c + 1 cp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.priorknotidx-Union{Tuple{ET}, Tuple{T}, Tuple{Interpolations.KnotIterator{T, ET}, Any}} where {T, ET}","page":"Library","title":"Interpolations.priorknotidx","text":"priorknotidx(iter::KnotIterator, x)\n\nReturns the index of the last knot such that k < x or nothing ig not such knot exists.\n\nNew boundary conditions should define\n\npriorknotidx(::Type{<:NewBoundaryCondition}, knots::Vector, x)\n\nWhere knots is iter.knots and NewBoundaryCondition is the new boundary condition. This method is expected to handle values of x that are both inbounds or extrapolated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.rescale_gradient","page":"Library","title":"Interpolations.rescale_gradient","text":"rescale_gradient(r::AbstractRange)\n\nImplements the chain rule dy/dx = dy/du * du/dx for use when calculating gradients with scaled interpolation objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.root_storage_type-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractInterpolation","page":"Library","title":"Interpolations.root_storage_type","text":"Interpolations.root_storage_type(::Type{<:AbstractInterpolation}) -> Type{<:AbstractArray}\n\nThis function returns the type of the root coefficients array of an AbstractInterpolation. Some array wrappers, like OffsetArray, should be skipped.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.show_ranged-Tuple{IO, Any, Any}","page":"Library","title":"Interpolations.show_ranged","text":"show_ranged(io, X, knots)\n\nA replacement for the default array-show for types that may not have the canonical evaluation points. rngs is the tuple of knots along each axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.value_weights","page":"Library","title":"Interpolations.value_weights","text":"w = value_weights(degree, δx)\n\nCompute the weights for interpolation of the value at an offset δx from the \"base\" position. degree describes the interpolation scheme.\n\nExample\n\njulia> Interpolations.value_weights(Linear(), 0.2)\n(0.8, 0.2)\n\nThis corresponds to the fact that linear interpolation at x + 0.2 is 0.8*y[x] + 0.2*y[x+1].\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.weightedindexes-Union{Tuple{N}, Tuple{F}, Tuple{F, Tuple{Vararg{Interpolations.Flag, N}}, Tuple{Vararg{AbstractVector{T} where T, N}}, Tuple{Vararg{Number, N}}}} where {F, N}","page":"Library","title":"Interpolations.weightedindexes","text":"weightedindexes(fs, itpflags, nodes, xs)\n\nCompute WeightedIndex values for evaluation at the position xs.... fs is a function or tuple of functions indicating the types of index required, typically value_weights, gradient_weights, and/or hessian_weights. itpflags and nodes can be obtained from itpinfo(itp)....\n\nSee the \"developer documentation\" for further information.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.BSplineInterpolation","page":"Library","title":"Interpolations.BSplineInterpolation","text":"BSplineInterpolation{T,N,TCoefs,IT,Axs}\n\nAn interpolant-type for b-spline interpolation on a uniform grid with integer nodes. T indicates the element type for operations like collect(itp), and may also agree with the values obtained from itp(x, y, ...) at least for certain types of x and y. N is the dimensionality of the interpolant. The remaining type-parameters describe the types of fields:\n\nthe coefs field holds the interpolation coefficients. Depending on prefiltering, these may or may not be the same as the supplied array of interpolant values.\nparentaxes holds the axes of the parent. Depending on prefiltering this may be \"narrower\" than the axes of coefs.\nit holds the interpolation type, e.g., BSpline(Linear()) or (BSpline(Quadratic(OnCell()),BSpline(Linear())).\n\nBSplineInterpolation objects are typically created with interpolate. However, for customized control you may also construct them with\n\nBSplineInterpolation(TWeights, coefs, it, axs)\n\nwhere T gets computed from the product of TWeights and eltype(coefs). (This is equivalent to indicating that you'll be evaluating at locations itp(x::TWeights, y::TWeights, ...).)\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.BoundaryCondition","page":"Library","title":"Interpolations.BoundaryCondition","text":"BoundaryCondition\n\nAn abstract type with one of the following values (see the help for each for details):\n\nThrow(gt)\nFlat(gt)\nLine(gt)\nFree(gt)\nPeriodic(gt)\nReflect(gt)\nInPlace(gt)\nInPlaceQ(gt)\n\nwhere gt is the grid type, e.g., OnGrid() or OnCell().\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.BoundsCheckStyle","page":"Library","title":"Interpolations.BoundsCheckStyle","text":"BoundsCheckStyle(itp)\n\nA trait to determine dispatch of bounds-checking for itp. Can return NeedsCheck(), in which case bounds-checking is performed, or CheckWillPass() in which case the check will return true.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.GriddedInterpolation-Union{Tuple{IT}, Tuple{TWeights}, Tuple{TCoefs}, Tuple{N}, Tuple{Type{TWeights}, Tuple{Vararg{AbstractUnitRange, N}}, AbstractArray{TCoefs, N}, IT}} where {N, TCoefs, TWeights<:Real, IT<:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded}, N} where N}, Gridded}}","page":"Library","title":"Interpolations.GriddedInterpolation","text":"GriddedInterpolation(typeOfWeights::Type{<:Real},\n                     knots::NTuple{N, AbstractUnitRange },\n                     array::AbstractArray{TCoefs,N},\n                     interpolationType::DimSpec{<:Gridded})\n\nConstruct a GriddedInterpolation for generic knots from an AbstractUnitRange.\n\nAbstractUnitRanges are collected to an Array to not confuse bound calculations (See Issue #398)\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.GriddedInterpolation-Union{Tuple{IT}, Tuple{TWeights}, Tuple{Tel}, Tuple{N}, Tuple{Type{TWeights}, Tuple{Vararg{Union{AbstractVector{T}, Tuple} where T, N}}, AbstractArray{Tel, N}, IT}} where {N, Tel, TWeights<:Real, IT<:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded}, N} where N}, Gridded}}","page":"Library","title":"Interpolations.GriddedInterpolation","text":"GriddedInterpolation(typeOfWeights::Type{<:Real},\n                     knots::NTuple{N, Union{ AbstractVector{T}, Tuple } },\n                     array::AbstractArray{Tel,N},\n                     interpolationType::DimSpec{<:Gridded})\n\nConstruct a GriddedInterpolation for generic knots from an AbstractArray\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.KnotIterator","page":"Library","title":"Interpolations.KnotIterator","text":"KnotIterator{T,ET}(k::AbstractArray{T}, bc::ET)\n\nDefines an iterator over the knots in k based on the boundary conditions bc.\n\nFields\n\nknots::Vector{T} The interpolated knots of the axis to iterate over\nbc::ET The Boundary Condition for the axis\nnknots::Int The number of interpolated knots (ie. length(knots))\n\nET is Union{BoundaryCondition,Tuple{BoundaryCondition,BoundaryCondition}}\n\nIterator Interface\n\nThe following methods defining Julia's iterator interface have been defined\n\nIteratorSize(::Type{KnotIterator}) -> Will return one of the following\n\nBase.IsInfinite if the iteration will produces an infinite sequence of knots\nBase.HasLength if iteration will produce a finite sequence of knots\nBase.SizeUnknown if we can't decided from only the type information\n\nlength and size -> Are defined if IteratorSize is HasLength, otherwise will raise a MethodError.\n\nIteratorEltype will always return HasEltype, as we always track the data types of the knots\n\neltype will return the data type of the knots\n\niterate Defines iteration over the knots starting from the first one and moving in the forward direction along the axis.\n\nKnots for Multi-dimensional Interpolants\n\nIteration over the knots of a multi-dimensional interpolant is done by wrapping multiple KnotIterator within Iterators.product.\n\nIndexing\n\nKnotIterator provides limited support for accessing knots via indexing\n\ngetindex is provided for KnotIterator but does not support Multidimensional interpolations (As wrapped by ProductIterator) or non-Int indexes.\nA BoundsError will be raised if out of bounds and checkbounds has been implemented for KnotIterator\n\njulia> using Interpolations;\n\njulia> etp = linear_interpolation([1.0, 1.2, 2.3, 3.0], rand(4); extrapolation_bc=Periodic());\n\njulia> kiter = knots(etp);\n\njulia> kiter[4]\n3.0\n\njulia> kiter[36]\n24.3\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.KnotRange","page":"Library","title":"Interpolations.KnotRange","text":"KnotRange(iter::KnotIterator{T}, start, stop)\n\nDefines an iterator over a range of knots such that start < k < stop.\n\nFields\n\niter::KnotIterator{T} Underlying KnotIterator providing the knots iterated\nrange::R Iterator defining the range of knot indices iterated. Where R <: Union{Iterators.Count, UnitRange}\n\nIterator Interface\n\nThe following methods defining the Julia's iterator interface have been defined\n\nBase.IteratorSize -> Will return one of the following:\n\nBase.HasLength if range is of finite length\nBase.IsInfinite if range is of infinite length\nBase.SizeUnknown if the type of range is unspecified\n\nBase.IteratorEltype -> Returns Base.EltypeUnknown if type parameter not provided, otherwise Base.HasEltype\n\nlength and size -> Returns the number of knots to be iterated if IteratorSize !== IsInfinite, otherwise will raise MethodError\n\nMultidimensional Interpolants\n\nIteration over the knots of a multi-dimensional interpolant is done by wrapping multiple KnotRange iterators within Iterators.product.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.LanczosInterpolation","page":"Library","title":"Interpolations.LanczosInterpolation","text":"LanczosInterpolation\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.MonotonicInterpolation","page":"Library","title":"Interpolations.MonotonicInterpolation","text":"MonotonicInterpolation\n\nMonotonic interpolation up to third order represented by type, knots and coefficients.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.MonotonicInterpolationType","page":"Library","title":"Interpolations.MonotonicInterpolationType","text":"MonotonicInterpolationType\n\nAbstract class for all types of monotonic interpolation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.WeightedIndex","page":"Library","title":"Interpolations.WeightedIndex","text":"wi = WeightedIndex(indexes, weights)\n\nConstruct a weighted index wi, which can be thought of as a generalization of an ordinary array index to the context of interpolation. For an ordinary vector a, a[i] extracts the element at index i. When interpolating, one is typically interested in a range of indexes and the output is some weighted combination of array values at these indexes. For example, for linear interpolation at a location x between integers i and i+1, we have\n\nret = (1-f)*a[i] + f*a[i+1]\n\nwhere f = x-i lies between 0 and 1. This can be represented as a[wi], where\n\nwi = WeightedIndex(i:i+1, (1-f, f))\n\ni.e.,\n\nret = sum(a[indexes] .* weights)\n\nLinear interpolation thus constructs weighted indices using a 2-tuple for weights and a length-2 indexes range. Higher-order interpolation would involve more positions and weights (e.g., 3-tuples for quadratic interpolation, 4-tuples for cubic).\n\nIn multiple dimensions, separable interpolation schemes are implemented in terms of multiple weighted indices, accessing A[wi1, wi2, ...] where each wi is the WeightedIndex along the corresponding dimension.\n\nFor value interpolation, weights will typically sum to 1. However, for gradient and Hessian computation this will not necessarily be true. For example, the gradient of one-dimensional linear interpolation can be represented as\n\ngwi = WeightedIndex(i:i+1, (-1, 1))\ng1 = a[gwi]\n\nFor a three-dimensional array A, one might compute ∂A/∂x₂ (the second component of the gradient) as A[wi1, gwi2, wi3], where wi1 and wi3 are \"value\" weights and gwi2 \"gradient\" weights.\n\nindexes may be supplied as a range or as a tuple of the same length as weights. The latter is applicable, e.g., for periodic boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"iterate/#Knot-Iteration","page":"Knot Iteration","title":"Knot Iteration","text":"","category":"section"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"Given an AbstractInterpolation itp get an iterator over its knots using knots(itp)","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"using Interpolations\nitp = interpolate(rand(4), options...)\nkiter = knots(itp) # Iterator over knots\ncollect(kiter) # Array of knots [1, 2, 3, 4]\n","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"For multiple dimensions, the iterator will return tuples of positions (ie. (x, y, ...)),  with the first coordinate changing the fastest.","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> itp = interpolate(ones(3,3), BSpline(Linear()));\n\njulia> kiter = knots(itp);\n\njulia> collect(kiter)\n3×3 Matrix{Tuple{Int64, Int64}}:\n (1, 1)  (1, 2)  (1, 3)\n (2, 1)  (2, 2)  (2, 3)\n (3, 1)  (3, 2)  (3, 3)","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"The number of elements and size of the iterator can be found as shown:","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> length(kiter)\n9\n\njulia> size(kiter)\n(3, 3)\n","category":"page"},{"location":"iterate/#Extrapolated-Knots","page":"Knot Iteration","title":"Extrapolated Knots","text":"","category":"section"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"Given an AbstractExtrapolation etp, knots(etp) will also iterate over the knots with the following behavior.","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"For Throw, Flat, Line iterate the knots once\nFor Periodic and Reflect generate an infinite sequence of knots starting at the first knot.","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"As Periodic and Reflect generate infinite sequences of knots, length and size are undefined. For Throw, Flat, Line, length and size behave as expected.","category":"page"},{"location":"iterate/#Periodic","page":"Knot Iteration","title":"Periodic","text":"","category":"section"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"With Periodic boundary condition, knots repeat indefinitely with the first and last knot being co-located. (ie. in the example below etp(2.0) = 1.0 not 4.0).","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> x = [1.0, 1.5, 1.75, 2.0];\n\njulia> etp = linear_interpolation(x, x.^2, extrapolation_bc=Periodic());\n\njulia> kiter = knots(etp);\n\njulia> k = Iterators.take(kiter, 6) |> collect\n6-element Vector{Float64}:\n 1.0\n 1.5\n 1.75\n 2.0\n 2.5\n 2.75\n","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"Extrapolating to the generated knots etp.(k), confirms that the extrapolated knots do map back to the correct inbound knots (ie. etp(k[1]) == etp(k[4])).","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> etp.(k)\n6-element Vector{Float64}:\n 1.0\n 2.25\n 3.0625\n 1.0\n 2.25\n 3.0625\n","category":"page"},{"location":"iterate/#Reflect","page":"Knot Iteration","title":"Reflect","text":"","category":"section"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"With the Reflect boundary condition knots repeat indefinitely, following the pattern shown below (Offset terms are not shown for brevity).","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"k[1], k[2], ..., k[end-1], k[end], k[end+1], ... k[2], k[1], k[2], ...","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> x = [1.0, 1.5, 1.75, 2.0];\n\njulia> etp = linear_interpolation(x, x.^2, extrapolation_bc=Reflect());\n\njulia> kiter = knots(etp);\n\njulia> k = Iterators.take(kiter, 6) |> collect\n6-element Vector{Float64}:\n 1.0\n 1.5\n 1.75\n 2.0\n 2.25\n 2.5\n","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"Evaluating the extrapolation at etp.(k) confirms that the extrapolated knots correspond to the correct inbound knots.","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> etp.(k)\n6-element Vector{Float64}:\n 1.0\n 2.25\n 3.0625\n 4.0\n 3.0625\n 2.25\n","category":"page"},{"location":"iterate/#Multiple-Dimensions","page":"Knot Iteration","title":"Multiple Dimensions","text":"","category":"section"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"As with an AbstractInterpolation, iterating over knots for a multi-dimensional extrapolation also supported.","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> x = [1.0, 1.5, 1.75, 2.0];\n\njulia> etp = linear_interpolation((x, x), x.*x');\n\njulia> knots(etp) |> collect\n4×4 Matrix{Tuple{Float64, Float64}}:\n (1.0, 1.0)   (1.0, 1.5)   (1.0, 1.75)   (1.0, 2.0)\n (1.5, 1.0)   (1.5, 1.5)   (1.5, 1.75)   (1.5, 2.0)\n (1.75, 1.0)  (1.75, 1.5)  (1.75, 1.75)  (1.75, 2.0)\n (2.0, 1.0)   (2.0, 1.5)   (2.0, 1.75)   (2.0, 2.0)\n","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"Because some boundary conditions generate an infinite sequence of knots, iteration over knots can end up \"stuck\" iterating along a single axis:","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> x = [1.0, 1.5, 1.75, 2.0];\n\njulia> etp = linear_interpolation((x, x), x.*x', extrapolation_bc=(Periodic(), Throw()));\n\njulia> knots(etp) |> k -> Iterators.take(k, 6) |> collect\n6-element Vector{Tuple{Float64, Float64}}:\n (1.0, 1.0)\n (1.5, 1.0)\n (1.75, 1.0)\n (2.0, 1.0)\n (2.5, 1.0)\n (2.75, 1.0)\n","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"Rearranging the axes so non-repeating knots are first can address this issue:","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> x = [1.0, 1.5, 1.75, 2.0];\n\njulia> etp = linear_interpolation((x, x), x.*x', extrapolation_bc=(Throw(), Periodic()));\n\njulia> knots(etp) |> k -> Iterators.take(k, 6) |> collect\n6-element Vector{Tuple{Float64, Float64}}:\n (1.0, 1.0)\n (1.5, 1.0)\n (1.75, 1.0)\n (2.0, 1.0)\n (1.0, 1.5)\n (1.5, 1.5)\n","category":"page"},{"location":"iterate/#Directional-Boundary-Conditions","page":"Knot Iteration","title":"Directional Boundary Conditions","text":"","category":"section"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"If the boundary conditions are directional, the forward boundary condition is used to determine if the iterator will generate an infinite sequence of knots.","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"For example the following extrapolation etp, will throw an error for values less than 1.0, but will use Periodic extrapolation for values above 2.0. As a result, the iterator will generate an infinite sequence of knots starting at 1.0.","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> x = [1.0, 1.2, 1.3, 2.0];\n\njulia> etp = linear_interpolation(x, x.^2, extrapolation_bc=((Throw(), Periodic()),));\n\njulia> kiter = knots(etp);\n\njulia> kiter |> k -> Iterators.take(k, 5) |> collect\n5-element Vector{Float64}:\n 1.0\n 1.2\n 1.3\n 2.0\n 2.2\n","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"We can also check if the iterator has a length using: Base.IteratorSize","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> Base.IteratorSize(kiter)\nBase.IsInfinite()\n","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"Swapping the boundary conditions, results in a finite sequence of knots from 1.0 to 2.0.","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> x = [1.0, 1.2, 1.3, 2.0];\n\njulia> etp = linear_interpolation(x, x.^2, extrapolation_bc=((Periodic(), Throw()),));\n\njulia> kiter = knots(etp);\n\njulia> collect(kiter)\n4-element Vector{Float64}:\n 1.0\n 1.2\n 1.3\n 2.0\n","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"As expected the iterator now has a defined length:","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> Base.IteratorSize(kiter)\nBase.HasLength()\n\njulia> length(kiter)\n4\n\njulia> size(kiter)\n(4,)\n","category":"page"},{"location":"iterate/#knotsbetween","page":"Knot Iteration","title":"knotsbetween","text":"","category":"section"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"Given an AbstractInterpolation itp or results of knots(itp) get an iterator over knots between start and stop.","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"using Interpolations\nitp = interpolate(rand(4), options...)\nkrange = knotsbetween(itp; start=1.2, stop=3.0)\ncollect(kiter) # Array of knots between 1.2 and 3.0\n","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"We can iterate over all knots greater than start by omitting stop","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> x = [1.0, 1.5, 1.75, 2.0];\n\njulia> etp = linear_interpolation(x, x.^2, extrapolation_bc=Periodic());\n\njulia> krange = knotsbetween(etp; start=4.0);\n\njulia> Iterators.take(krange, 5) |> collect\n5-element Vector{Float64}:\n 4.5\n 4.75\n 5.0\n 5.5\n 5.75\n","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"If we omit start, iteration will range from the first knot to stop","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> krange = knotsbetween(etp; stop=4.0);\n\njulia> collect(krange)\n9-element Vector{Float64}:\n 1.0\n 1.5\n 1.75\n 2.0\n 2.5\n 2.75\n 3.0\n 3.5\n 3.75\n","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"It is an error to not provided start and stop","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> knotsbetween(etp)\nERROR: ArgumentError: At least one of `start` or `stop` must be specified\n[...]","category":"page"},{"location":"iterate/#Multiple-Dimensions-2","page":"Knot Iteration","title":"Multiple Dimensions","text":"","category":"section"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"When used with a multi-dimensional interpolant, knotsbetween can be used to iterate overall knots such that: start[i] < k[i] stop[i] where i indexes dimensions.","category":"page"},{"location":"iterate/","page":"Knot Iteration","title":"Knot Iteration","text":"julia> x = [1.0, 1.5, 1.75, 2.0];\n\njulia> etp = linear_interpolation((x, x), x.*x');\n\njulia> knotsbetween(etp; start=(1.2, 1.5), stop=(1.8, 3.0)) |> collect\n2×2 Matrix{Tuple{Float64, Float64}}:\n (1.5, 1.75)   (1.5, 2.0)\n (1.75, 1.75)  (1.75, 2.0)\n","category":"page"},{"location":"chainrules/#ChainRulesCore-Integration","page":"-","title":"ChainRulesCore Integration","text":"","category":"section"},{"location":"chainrules/","page":"-","title":"-","text":"The WeightedIndex infrastructure has issues working with autodiff libraries. Autodiff is facilitate by integration with ChainRulesCore. A custom rrule is defined such that","category":"page"},{"location":"chainrules/","page":"-","title":"-","text":"y, itp_pullback = rrule(itp, 1)","category":"page"},{"location":"chainrules/","page":"-","title":"-","text":"itp_pullback takes a perturbation on y and returns how it effects each x dimension. Since Interpolations already has a gradient function, pullback reuses it by scaling it by Δy.","category":"page"},{"location":"chainrules/","page":"-","title":"-","text":"This enables integration with autodiff libraries like Zygote, enabling","category":"page"},{"location":"chainrules/","page":"-","title":"-","text":"x = 1:10\ny = sin.(x)\nitp = interpolate(y,BSpline(Linear()))\nZygote.gradient(itp, 2)\n#([-0.7681774187658145],)","category":"page"},{"location":"devdocs/#Developer-documentation","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Conceptually, Interpolations.jl supports two operations: construction and usage of interpolants.","category":"page"},{"location":"devdocs/#Interpolant-construction","page":"Developer documentation","title":"Interpolant construction","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Construction creates the interpolant object. In some situations this is relatively trivial: for example, when using only NoInterp, Constant, or Linear interpolation schemes, construction essentially corresponds to recording the array of values and the \"settings\" (the interpolation scheme) specified at the time of construction. This case is simple because interpolated values may be efficiently computed directly from the on-grid values supplied at construction time: (1-Delta x) a_i  + Delta x a_i+1 reconstructs a_i when Delta x = 0.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"For Quadratic and higher orders, efficient computation requires that the array of values be prefiltered. This essentially corresponds to \"inverting\" the computation that will be performed during interpolation, so as to approximately reconstruct the original values at on-grid points. Generally speaking this corresponds to solving a nearly-tridiagonal system of equations, inverting an underlying interpolation scheme such as p(Delta x) tilde a_i-1 + q(Delta x) tilde a_i + p(1-Delta x) tilde a_i+1 for some functions p and q (see Quadratic for further details). Here tilde a is the pre-filtered version of a, designed so that substituting Delta x = 0 (for which one may not get 0 and 1 for the p and q calls, respectively) approximately recapitulates a_i.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"The exact system of equations to be solved depends on the interpolation order and boundary conditions. Boundary conditions often introduce deviations from perfect tridiagonality; these \"extras\" are handled efficiently by the WoodburyMatrices package. These computations are implemented independently along each axis using the AxisAlgorithms package.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"In the doc directory there are some old files that give some of the mathematical details. A useful reference is:","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Thévenaz, Philippe, Thierry Blu, and Michael Unser. \"Interpolation revisited.\" IEEE Transactions on Medical Imaging 19.7 (2000): 739-758.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"note: Note\nAs an application of these concepts, note that supporting quadratic or cubic interpolation for Gridded would only require that someone implement prefiltering schemes for non-uniform grids; it's just a question of working out a little bit of math.","category":"page"},{"location":"devdocs/#Interpolant-usage","page":"Developer documentation","title":"Interpolant usage","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Usage occurs when evaluating itp(x, y...), or Interpolations.gradient(itp, x, y...), etc. Usage itself involves two sub-steps: computation of the weights and then performing the interpolation.","category":"page"},{"location":"devdocs/#Weight-computation","page":"Developer documentation","title":"Weight computation","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Weights depend on the interpolation scheme and the location x, y... but not the coefficients of the array we are interpolating. Consequently there are many circumstances where one might want to reuse previously-computed weights, and Interpolations.jl has been carefully designed with that kind of reuse in mind.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"The key concept here is the Interpolations.WeightedIndex, and there is no point repeating its detailed docstring here. It suffices to add that WeightedIndex is actually an abstract type, with two concrete subtypes:","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"WeightedAdjIndex is for indexes that will address adjacent points of the coefficient array (ones where the index increments by 1 along the corresponding dimension). These are used when prefiltering produces padding that can be used even at the edges, or for schemes like Linear interpolation which require no padding.\nWeightedArbIndex stores both the weight and index associated with each accessed grid point, and can therefore encode grid access patterns. These are used in specific circumstances–a prime example being periodic boundary conditions–where the coefficients array may be accessed at something other than adjacent locations.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"WeightedIndex computation reflects the interpolation scheme (e.g., Linear or Quadratic) and also whether one is computing values, gradients, or hessians. The handling of derivatives will be described further below.","category":"page"},{"location":"devdocs/#Interpolation","page":"Developer documentation","title":"Interpolation","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"General AbstractArrays may be indexed with WeightedIndex indices, and the result produces the interpolated value. In other words, the end result is just itp.coefs[wis...], where wis is a tuple of WeightedIndex indices. To make sure this overloading is effective, we wrap the coefs with InterpGetindex， i.e. InterpGetindex(itp.coefs)[wis...]","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Derivatives along a particular axis can be computed just by substituting a component of wis for one that has been designed to compute derivatives rather than values.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"As a demonstration, let's see how the following computation occurs:","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"julia> A = reshape(1:27, 3, 3, 3)\n3×3×3 reshape(::UnitRange{Int64}, 3, 3, 3) with eltype Int64:\n[:, :, 1] =\n 1  4  7\n 2  5  8\n 3  6  9\n\n[:, :, 2] =\n 10  13  16\n 11  14  17\n 12  15  18\n\n[:, :, 3] =\n 19  22  25\n 20  23  26\n 21  24  27\n\njulia> itp = interpolate(A, BSpline(Linear()));\n\njulia> x = (1.2, 1.4, 1.7)\n(1.2, 1.4, 1.7)\n\njulia> itp(x...)\n8.7","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"note: Note\nBy using the debugging facilities of an IDE like Juno or VSCode, or using Debugger.jl from the REPL, you can easily step in to the call above and follow along with the description below.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Aside from details such as bounds-checking, the key call is to Interpolations.weightedindexes:","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"julia> wis = Interpolations.weightedindexes((Interpolations.value_weights,), Interpolations.itpinfo(itp)..., x)\n(Interpolations.WeightedAdjIndex{2, Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2, Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2, Float64}(1, (0.30000000000000004, 0.7)))\n\njulia> wis[1]\nInterpolations.WeightedAdjIndex{2, Float64}(1, (0.8, 0.19999999999999996))\n\njulia> wis[2]\nInterpolations.WeightedAdjIndex{2, Float64}(1, (0.6000000000000001, 0.3999999999999999))\n\njulia> wis[3]\nInterpolations.WeightedAdjIndex{2, Float64}(1, (0.30000000000000004, 0.7))\n\njulia> Interpolations.InterpGetindex(A)[wis...]\n8.7","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"You can see that each of wis corresponds to a specific position: 1.2, 1.4, and 1.7 respectively. We can index A at wis, and it returns the value of itp(x...), which here is just","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"  0.8 * A[1, wis[2], wis[3]] + 0.2 * A[2, wis[2], wis[3]]\n= 0.6 * (0.8 * A[1, 1, wis[3]] + 0.2 * A[2, 1, wis[3]]) +\n  0.4 * (0.8 * A[1, 2, wis[3]] + 0.2 * A[2, 2, wis[3]])\n= 0.3 * (0.6 * (0.8 * A[1, 1, 1] + 0.2 * A[2, 1, 1]) +\n         0.4 * (0.8 * A[1, 2, 1] + 0.2 * A[2, 2, 1])  ) +\n  0.7 * (0.6 * (0.8 * A[1, 1, 2] + 0.2 * A[2, 1, 2]) +\n         0.4 * (0.8 * A[1, 2, 2] + 0.2 * A[2, 2, 2])  )","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"This computed the value of itp at x... because we called weightedindexes with just a single function, Interpolations.value_weights (meaning, \"the weights needed to compute the value\").","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"note: Note\nRemember that prefiltering is not used for Linear interpolation. In a case where prefiltering is used, we would substitute InterpGetindex(itp.coefs)[wis...] for InterpGetindex(A)[wis...] above.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"To compute derivatives, we also pass additional functions like Interpolations.gradient_weights:","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"julia> wis = Interpolations.weightedindexes((Interpolations.value_weights, Interpolations.gradient_weights), Interpolations.itpinfo(itp)..., x)\n((Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7))), (Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7))), (Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0))))\n\njulia> wis[1]\n(Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7)))\n\njulia> wis[2]\n(Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7)))\n\njulia> wis[3]\n(Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)))\n\njulia> Interpolations.InterpGetindex(A)[wis[1]...]\n1.0\n\njulia> Interpolations.InterpGetindex(A)[wis[2]...]\n3.000000000000001\n\njulia> Interpolations.InterpGetindex(A)[wis[3]...]\n9.0","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"In this case you can see that wis is a 3-tuple-of-3-tuples. A[wis[i]...] can be used to compute the ith component of the gradient.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"If you look carefully at each of the entries in wis, you'll see that each \"inner\" 3-tuple copies two of the three elements in the wis we obtained when we called weightedindexes with just value_weights above. wis[1] replaces the first entry with a weighted index having weights (-1.0, 1.0), which corresponds to computing the slope along this dimension. Likewise wis[2] and wis[3] replace the second and third value-index, respectively, with the same slope computation.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Hessian computation is quite similar, with the difference that one sometimes needs to replace two different indices or the same index with a set of weights corresponding to a second derivative.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Consequently derivatives along particular directions are computed simply by \"weight replacement\" along the corresponding dimensions.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"The code to do this replacement is a bit complicated due to the need to support arbitrary dimensionality in a manner that allows Julia's type-inference to succeed. It makes good use of tuple manipulations, sometimes called \"lispy tuple programming.\" You can search Julia's discourse forum for more tips about how to program this way. It could alternatively be done using generated functions, but this would increase compile time considerably and can lead to world-age problems.","category":"page"},{"location":"devdocs/#GPU-Support","page":"Developer documentation","title":"GPU Support","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"At present, Interpolations.jl supports interpolant usage on GPU via broadcasting.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"A basic work flow looks like:","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"julia> using Interpolations, Adapt, CUDA # Or any other GPU package\n\njulia > itp = Interpolations.interpolate([1, 2, 3], (BSpline(Linear()))); # construct the interpolant object on CPU\n\njulia> cuitp = adapt(CuArray{Float32}, itp); # adapt it to GPU memory\n\njulia > cuitp.(1:0.5:2) # call interpolant object via broadcast\n\njulia> gradient.(Ref(cuitp), 1:0.5:2)","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"To achieve this, an ITP <: AbstractInterpolation should define it's own Adapt.adapt_structure(to, itp::ITP), which constructs a new ITP with the adapted fields (adapt(to, itp.fieldname)) of itp. The field adaption could be skipped if we know that it has been GPU-compatable, e.g. a isbit range.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"note: Note\nSome adaptors may change the storage type. Please ensure that the adapted itp has the correct element type via the method eltype.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Also, all GPU-compatable AbstractInterpolations should define their own Interpolations.root_storage_type. This function allows us to modify the broadcast mechanism by overloading the default BroadcastStyle. See Customizing broadcasting for more details.","category":"page"},{"location":"extrapolation/#Extrapolation","page":"Extrapolation","title":"Extrapolation","text":"","category":"section"},{"location":"extrapolation/","page":"Extrapolation","title":"Extrapolation","text":"The call to extrapolate defines what happens if you try to index into the interpolation object with coordinates outside of its bounds in any dimension. The implemented boundary conditions are Throw, Flat, Line, Periodic and Reflect, or you can pass a constant to be used as a \"fill\" value returned for any out-of-bounds evaluation. Periodic and Reflect require that there is a method of Base.mod that can handle the indices used.","category":"page"},{"location":"extrapolation/","page":"Extrapolation","title":"Extrapolation","text":"Examples:","category":"page"},{"location":"extrapolation/","page":"Extrapolation","title":"Extrapolation","text":"itp = interpolate(1:7, BSpline(Linear()))\netpf = extrapolate(itp, Flat())   # gives 1 on the left edge and 7 on the right edge\netp0 = extrapolate(itp, 0)        # gives 0 everywhere outside [1,7]","category":"page"},{"location":"extrapolation/#Periodic-extrapolation","page":"Extrapolation","title":"Periodic extrapolation","text":"","category":"section"},{"location":"extrapolation/","page":"Extrapolation","title":"Extrapolation","text":"For uniformly sampled periodic data, one can perform periodic extrapolation for all types of B-Spline interpolations. By using the Periodic(OnCell()) boundary condition in interpolate, one does not need to include the periodic image of the starting sample point.","category":"page"},{"location":"extrapolation/","page":"Extrapolation","title":"Extrapolation","text":"Examples:","category":"page"},{"location":"extrapolation/","page":"Extrapolation","title":"Extrapolation","text":"f(x) = sin((x-3)*2pi/7 - 1)\nA = Float64[f(x) for x in 1:7] # Does not include the periodic image\n\n# Constant(Periodic())) is an alias for Constant{Nearest}(Periodic(OnCell()))\nitp0 = interpolate(A, BSpline(Constant(Periodic())))\n# Linear(Periodic())) is an alias for Linear(Periodic(OnCell()))\nitp1 = interpolate(A, BSpline(Linear(Periodic())))\nitp2 = interpolate(A, BSpline(Quadratic(Periodic(OnCell()))))\nitp3 = interpolate(A, BSpline(Cubic(Periodic(OnCell()))))\n\netp0 = extrapolate(itp0, Periodic())\netp1 = extrapolate(itp1, Periodic())\netp2 = extrapolate(itp2, Periodic())\netp3 = extrapolate(itp3, Periodic())","category":"page"},{"location":"#Interpolations","page":"Home","title":"Interpolations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: version) (Image: pkgeval) (Image: Build Status) (Image: deps) (Image: Stable) (Image: Latest)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package Interpolations.jl implements a variety of interpolation schemes for the Julia language.  It has the goals of ease-of-use, broad algorithmic support, and exceptional performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently this package supports B-splines and irregular grids.  The API has been designed with intent to support more options. Pull-requests are more than welcome! It should be noted that the API may continue to evolve over time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are many other interpolation packages implemented in Julia. For a listing, see Other Interpolation Packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some of these packages support methods that Interpolations does not, so if you can't find what you need here, check one of them or submit a pull request here.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Interpolations.jl can be installed via the following invocation since it is a registered Julia package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Interpolations\")","category":"page"},{"location":"#Example-Usage","page":"Home","title":"Example Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Create a grid xs and an array A of values to be interpolated","category":"page"},{"location":"","page":"Home","title":"Home","text":"xs = 1:0.2:5\nA = log.(xs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create linear interpolation object without extrapolation","category":"page"},{"location":"","page":"Home","title":"Home","text":"interp_linear = linear_interpolation(xs, A)\ninterp_linear(3) # exactly log(3)\ninterp_linear(3.1) # approximately log(3.1)\ninterp_linear(0.9) # outside grid: error","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create linear interpolation object with extrapolation","category":"page"},{"location":"","page":"Home","title":"Home","text":"interp_linear_extrap = linear_interpolation(xs, A,extrapolation_bc=Line()) \ninterp_linear_extrap(0.9) # outside grid: linear extrapolation","category":"page"},{"location":"#Performant-Example-Usage","page":"Home","title":"Performant Example Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The above use of LinearInterpolation is actually a short hand for a composition of interpolate, scale, and extrapolate. You may not need all of the the scaling and extrapolation features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"interp_linear = extrapolate(scale(interpolate(A, BSpline(Linear())), xs))","category":"page"},{"location":"","page":"Home","title":"Home","text":"If we know we do not need the extrapolation portion, we can use the following.","category":"page"},{"location":"","page":"Home","title":"Home","text":"scaled_itp = scale(interpolate(A, BSpline(Linear())), xs)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can also remove the scaling for further performance if integer valued knots and regular grids are sufficient.","category":"page"},{"location":"","page":"Home","title":"Home","text":"itp = interpolate(A, BSpline(Linear()))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Removing the scaling or extrapolation will help accelerate interpolation by removing unneeded operations and branches. This can permit the use of advanced processor Single Instruction/Multiple Data (SIMD) capabilities.","category":"page"},{"location":"#Regular-Grids","page":"Home","title":"Regular Grids","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Interpolations.jl is optimized for use with regular grids with uniform spacing. The highest performance is achieved when the knots are an AbstractUnitRange such as 2:5 or Base.OneTo(9). The default case if no knots are specified is to assign the knots as a UnitRange starting at 1.","category":"page"},{"location":"#Scaling","page":"Home","title":"Scaling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the knots are not unit spaced or start at a distinct value other than 1, then the scale function can be used. While this increases the flexibility of the interpolation, some performance penalty is acquired. See Scaled BSplines for further information.","category":"page"},{"location":"#Irregular-Grids","page":"Home","title":"Irregular Grids","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the knots are irregularly spaced, then the ranges between knots will have to be scaled as in the Gridded interpolation type. See Gridded interpolation for additional details.","category":"page"},{"location":"#Points-outside-the-knots","page":"Home","title":"Points outside the knots","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For points not between knots, extrapolation can be used. This introduces a branch into the code that checks whether the point to be queried is inside or outside of the knots. This branch can inhibit the use of vectorized SIMD computation, resulting in a reduction of performance. See Extrapolation.","category":"page"},{"location":"control/#Control-of-interpolation-algorithm","page":"Interpolation algorithms","title":"Control of interpolation algorithm","text":"","category":"section"},{"location":"control/#BSplines","page":"Interpolation algorithms","title":"BSplines","text":"","category":"section"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"The interpolation type is described in terms of degree and, if necessary, boundary conditions. There are currently four degrees available: Constant, Linear, Quadratic,  and Cubic corresponding to B-splines of degree 0, 1, 2, and 3 respectively.","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"B-splines of quadratic or higher degree require solving an equation system to obtain the interpolation coefficients, and for that you must specify a boundary condition that is applied to close the system. The following boundary conditions are implemented: Flat, Line (alternatively, Natural), Free, Periodic and Reflect; their mathematical implications are described in detail in their docstrings. When specifying these boundary conditions you also have to specify whether they apply at the edge grid point (OnGrid()) or beyond the edge point halfway to the next (fictitious) grid point (OnCell()).","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Some examples:","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"# Nearest-neighbor interpolation\nitp = interpolate(a, BSpline(Constant()))\nv = itp(5.4)   # returns a[5]\n\n# Previous-neighbor interpolation\nitp = interpolate(a, BSpline(Constant(Previous)))\nv = itp(1.8)   # returns a[1]\n\n# Next-neighbor interpolation\nitp = interpolate(a, BSpline(Constant(Next)))\nv = itp(5.4)   # returns a[6]\n\n# (Multi)linear interpolation\nitp = interpolate(A, BSpline(Linear()))\nv = itp(3.2, 4.1)  # returns 0.9*(0.8*A[3,4]+0.2*A[4,4]) + 0.1*(0.8*A[3,5]+0.2*A[4,5])\n\n# Quadratic interpolation with reflecting boundary conditions\n# Quadratic is the lowest order that has continuous gradient\nitp = interpolate(A, BSpline(Quadratic(Reflect(OnCell()))))\n\n# Linear interpolation in the first dimension, and no interpolation (just lookup) in the second\nitp = interpolate(A, (BSpline(Linear()), NoInterp()))\nv = itp(3.65, 5)  # returns  0.35*A[3,5] + 0.65*A[4,5]","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"There are more options available, for example:","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"# In-place interpolation\nitp = interpolate!(A, BSpline(Quadratic(InPlace(OnCell()))))","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"which destroys the input A but also does not need to allocate as much memory.","category":"page"},{"location":"control/#Scaled-BSplines","page":"Interpolation algorithms","title":"Scaled BSplines","text":"","category":"section"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"BSplines assume your data is uniformly spaced on the grid 1:N, or its multidimensional equivalent. If you have data of the form [f(x) for x in A], you need to tell Interpolations about the grid A. If A is not uniformly spaced, you must use gridded interpolation described below. However, if A is a collection of ranges or linspaces, you can use scaled BSplines. This is more efficient because the gridded algorithm does not exploit the uniform spacing. Scaled BSplines can also be used with any spline degree available for BSplines, while gridded interpolation does not currently support quadratic or cubic splines.","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Some examples,","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"A_x = 1.:2.:40.\nA = [log(x) for x in A_x]\nitp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))\nsitp = scale(itp, A_x)\nsitp(3.) # exactly log(3.)\nsitp(3.5) # approximately log(3.5)","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"For multidimensional uniformly spaced grids","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"A_x1 = 1:.1:10\nA_x2 = 1:.5:20\nf(x1, x2) = log(x1+x2)\nA = [f(x1,x2) for x1 in A_x1, x2 in A_x2]\nitp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))\nsitp = scale(itp, A_x1, A_x2)\nsitp(5., 10.) # exactly log(5 + 10)\nsitp(5.6, 7.1) # approximately log(5.6 + 7.1)","category":"page"},{"location":"control/#Gridded-interpolation","page":"Interpolation algorithms","title":"Gridded interpolation","text":"","category":"section"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"These use a very similar syntax to BSplines, with the major exception being that one does not get to choose the grid representation (they are all OnGrid). As such one must specify a set of coordinate arrays defining the nodes of the array.","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"In 1D","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"A = rand(20)\nA_x = 1.0:2.0:40.0\nnodes = (A_x,)\nitp = interpolate(nodes, A, Gridded(Linear()))\nitp(2.0)","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"The spacing between adjacent samples need not be constant; indeed, if they are constant, you'll get better performance with scaled.","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"The general syntax is","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"itp = interpolate(nodes, A, options...)","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"where nodes = (xnodes, ynodes, ...) specifies the positions along each axis at which the array A is sampled for arbitrary (\"rectangular\") samplings.","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"For example:","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"A = rand(8,20)\nnodes = ([x^2 for x = 1:8], [0.2y for y = 1:20])\nitp = interpolate(nodes, A, Gridded(Linear()))\nitp(4,1.2)  # approximately A[2,6]","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"One may also mix modes, by specifying a mode vector in the form of an explicit tuple:","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"itp = interpolate(nodes, A, (Gridded(Linear()),Gridded(Constant())))","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Presently there are only three modes for gridded:","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Gridded(Linear())","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"whereby a linear interpolation is applied between nodes,","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Gridded(Constant())","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"whereby nearest neighbor interpolation is used on the applied axis,","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"NoInterp()","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"whereby the coordinate of the selected input vector MUST be located on a grid point. Requests for off grid coordinates results in the throwing of an error.","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"For Constant there are additional parameters. Use Constant{Previous}() in order to perform a previous neighbor interpolation. Use Constant{Next}() for a next neighbor interpolation. Note that rounding can be an issue, see #473.","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"missing data will naturally propagate through the interpolation, where some values will become missing. To avoid that, one can filter out the missing data points and use a gridded interpolation. For example:","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"x = 1:6\nA = [i == 3 ? missing : i for i in x]\nxf = [xi for (xi,a) in zip(x, A) if !ismissing(a)]\nAf = [a for a in A if !ismissing(a)]\nitp = interpolate((xf, ), Af, Gridded(Linear()))","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"In-place gridded interpolation is also possible:","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"x = 1:4\ny = view(rand(4), :)\nitp = interpolate!((x,), y, Gridded(Linear()))\ny .= 0\n@show itp(2.5) # 0","category":"page"},{"location":"control/#Parametric-splines","page":"Interpolation algorithms","title":"Parametric splines","text":"","category":"section"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Given a set a knots with coordinates x(t) and y(t), a parametric spline S(t) = (x(t),y(t)) parametrized by t in [0,1] can be constructed with the following code adapted from a post by Tomas Lycken:","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"using Interpolations\n\nt = 0:.1:1\nx = sin.(2π*t)\ny = cos.(2π*t)\nA = hcat(x,y)\n\nitp = Interpolations.scale(interpolate(A, (BSpline(Cubic(Natural(OnGrid()))), NoInterp())), t, 1:2)\n\ntfine = 0:.01:1\nxs, ys = [itp(t,1) for t in tfine], [itp(t,2) for t in tfine]","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"We can then plot the spline with:","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"using Plots\n\nscatter(x, y, label=\"knots\")\nplot!(xs, ys, label=\"spline\")","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"(Image: parametric spline)","category":"page"},{"location":"control/#Monotonic-interpolation","page":"Interpolation algorithms","title":"Monotonic interpolation","text":"","category":"section"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"When you have some one-dimensional data that is monotonic, many standard interpolation methods may give an interpolating function that it is not monotonic. Monotonic interpolation ensures that the interpolating function is also monotonic.","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Here is an example of making a cumulative distribution function for some data:","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"percentile_values = [0.0, 0.01, 0.1, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 99.9, 99.99, 100.0];\n\ny = sort(randn(length(percentile_values))); # some random data\n\nitp_cdf = extrapolate(interpolate(y, percentile_values, SteffenMonotonicInterpolation()), Flat());\n\nt = -3.0:0.01:3.0 # just a range for calculating values of the interpolating function\n\ninterpolated_cdf = map(itp_cdf, t) # interpolating the CDF","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"There are a few different monotonic interpolation algorithms. Some guarantee that for non-monotonic data the interpolating function does not exceed the range of values between two successive points while other do not (this is called overshooting in the list below).","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"LinearMonotonicInterpolation – simple linear interpolation. Does not overshoot.\nFiniteDifferenceMonotonicInterpolation – it may overshoot.\nCardinalMonotonicInterpolation – it may overshoot.\nFritschCarlsonMonotonicInterpolation – it may overshoot.\nFritschButlandMonotonicInterpolation – it does not overshoot.\nSteffenMonotonicInterpolation – it does not overshoot.","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"You can read about monotonic interpolation in the following sources:","category":"page"},{"location":"control/","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Fritsch & Carlson (1980), \"Monotone Piecewise Cubic Interpolation\", doi:10.1137/0717021.\nFritsch & Butland (1984), \"A Method for Constructing Local Monotone Piecewise Cubic Interpolants\", doi:10.1137/0905021.\nSteffen (1990), \"A Simple Method for Monotonic Interpolation in One Dimension\", URL","category":"page"}]
}
