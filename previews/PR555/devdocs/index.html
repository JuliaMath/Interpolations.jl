<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developer documentation · Interpolations.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Interpolations.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../convenience-construction/">Convenience Constructors</a></li><li><a class="tocitem" href="../interpolations/">General usage</a></li><li><a class="tocitem" href="../control/">Interpolation algorithms</a></li><li><a class="tocitem" href="../extrapolation/">Extrapolation</a></li><li><a class="tocitem" href="../iterate/">Knot Iteration</a></li><li class="is-active"><a class="tocitem" href>Developer documentation</a><ul class="internal"><li><a class="tocitem" href="#Interpolant-construction"><span>Interpolant construction</span></a></li><li><a class="tocitem" href="#Interpolant-usage"><span>Interpolant usage</span></a></li></ul></li><li><a class="tocitem" href="../api/">Library</a></li><li><a class="tocitem" href="../NEWS/">News and Changes</a></li><li><a class="tocitem" href="../other_packages/">Other Interpolation Packages</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developer documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developer documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/Interpolations.jl/blob/master/docs/src/devdocs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Developer-documentation"><a class="docs-heading-anchor" href="#Developer-documentation">Developer documentation</a><a id="Developer-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-documentation" title="Permalink"></a></h1><p>Conceptually, <code>Interpolations.jl</code> supports two operations: construction and usage of interpolants.</p><h2 id="Interpolant-construction"><a class="docs-heading-anchor" href="#Interpolant-construction">Interpolant construction</a><a id="Interpolant-construction-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolant-construction" title="Permalink"></a></h2><p>Construction creates the interpolant object. In some situations this is relatively trivial: for example, when using only <code>NoInterp</code>, <code>Constant</code>, or <code>Linear</code> interpolation schemes, construction essentially corresponds to recording the array of values and the &quot;settings&quot; (the interpolation scheme) specified at the time of construction. This case is simple because interpolated values may be efficiently computed directly from the on-grid values supplied at construction time: <span>$(1-\Delta x) a_i  + \Delta x a_{i+1}$</span> reconstructs <span>$a_i$</span> when <span>$\Delta x = 0$</span>.</p><p>For <code>Quadratic</code> and higher orders, efficient computation requires that the array of values be <em>prefiltered</em>. This essentially corresponds to &quot;inverting&quot; the computation that will be performed during interpolation, so as to approximately reconstruct the original values at on-grid points. Generally speaking this corresponds to solving a nearly-tridiagonal system of equations, inverting an underlying interpolation scheme such as <span>$p(\Delta x) \tilde a_{i-1} + q(\Delta x) \tilde a_i + p(1-\Delta x) \tilde a_{i+1}$</span> for some functions <span>$p$</span> and <span>$q$</span> (see <a href="../api/#Interpolations.Quadratic"><code>Quadratic</code></a> for further details). Here <span>$\tilde a$</span> is the pre-filtered version of <code>a</code>, designed so that substituting <span>$\Delta x = 0$</span> (for which one may <em>not</em> get 0 and 1 for the <span>$p$</span> and <span>$q$</span> calls, respectively) approximately recapitulates <span>$a_i$</span>.</p><p>The exact system of equations to be solved depends on the interpolation order and boundary conditions. Boundary conditions often introduce deviations from perfect tridiagonality; these &quot;extras&quot; are handled efficiently by the <code>WoodburyMatrices</code> package. These computations are implemented independently along each axis using the <code>AxisAlgorithms</code> package.</p><p>In the <code>doc</code> directory there are some old files that give some of the mathematical details. A useful reference is:</p><p>Thévenaz, Philippe, Thierry Blu, and Michael Unser. &quot;Interpolation revisited.&quot; IEEE Transactions on Medical Imaging 19.7 (2000): 739-758.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>As an application of these concepts, note that supporting quadratic or cubic interpolation for <code>Gridded</code> would only require that someone implement prefiltering schemes for non-uniform grids; it&#39;s just a question of working out a little bit of math.</p></div></div><h2 id="Interpolant-usage"><a class="docs-heading-anchor" href="#Interpolant-usage">Interpolant usage</a><a id="Interpolant-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolant-usage" title="Permalink"></a></h2><p>Usage occurs when evaluating <code>itp(x, y...)</code>, or <code>Interpolations.gradient(itp, x, y...)</code>, etc. Usage itself involves two sub-steps: computation of the <em>weights</em> and then performing the <em>interpolation</em>.</p><h3 id="Weight-computation"><a class="docs-heading-anchor" href="#Weight-computation">Weight computation</a><a id="Weight-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Weight-computation" title="Permalink"></a></h3><p>Weights depend on the interpolation scheme and the location <code>x, y...</code> but <em>not</em> the coefficients of the array we are interpolating. Consequently there are many circumstances where one might want to reuse previously-computed weights, and <code>Interpolations.jl</code> has been carefully designed with that kind of reuse in mind.</p><p>The key concept here is the <a href="../api/#Interpolations.WeightedIndex"><code>Interpolations.WeightedIndex</code></a>, and there is no point repeating its detailed docstring here. It suffices to add that <code>WeightedIndex</code> is actually an abstract type, with two concrete subtypes:</p><ul><li><code>WeightedAdjIndex</code> is for indexes that will address <em>adjacent</em> points of the coefficient array (ones where the index increments by 1 along the corresponding dimension). These are used when prefiltering produces padding that can be used even at the edges, or for schemes like <code>Linear</code> interpolation which require no padding.</li><li><code>WeightedArbIndex</code> stores both the weight and index associated with each accessed grid point, and can therefore encode grid access patterns. These are used in specific circumstances–a prime example being periodic boundary conditions–where the coefficients array may be accessed at something other than adjacent locations.</li></ul><p><code>WeightedIndex</code> computation reflects the interpolation scheme (e.g., <code>Linear</code> or <code>Quadratic</code>) and also whether one is computing values, <code>gradient</code>s, or <code>hessian</code>s. The handling of derivatives will be described further below.</p><h3 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h3><p>General <code>AbstractArray</code>s may be indexed with <code>WeightedIndex</code> indices, and the result produces the interpolated value. In other words, the end result is just <code>itp.coefs[wis...]</code>, where <code>wis</code> is a tuple of <code>WeightedIndex</code> indices. To make sure this overloading is effective, we wrap the <code>coefs</code> with <code>InterpGetindex</code>， i.e. <code>InterpGetindex(itp.coefs)[wis...]</code></p><p>Derivatives along a particular axis can be computed just by substituting a component of <code>wis</code> for one that has been designed to compute derivatives rather than values.</p><p>As a demonstration, let&#39;s see how the following computation occurs:</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(1:27, 3, 3, 3)
3×3×3 reshape(::UnitRange{Int64}, 3, 3, 3) with eltype Int64:
[:, :, 1] =
 1  4  7
 2  5  8
 3  6  9

[:, :, 2] =
 10  13  16
 11  14  17
 12  15  18

[:, :, 3] =
 19  22  25
 20  23  26
 21  24  27

julia&gt; itp = interpolate(A, BSpline(Linear()));

julia&gt; x = (1.2, 1.4, 1.7)
(1.2, 1.4, 1.7)

julia&gt; itp(x...)
8.7</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By using the debugging facilities of an IDE like Juno or VSCode, or using Debugger.jl from the REPL, you can easily step in to the call above and follow along with the description below.</p></div></div><p>Aside from details such as bounds-checking, the key call is to <a href="../api/#Interpolations.weightedindexes-Union{Tuple{N}, Tuple{F}, Tuple{F, Tuple{Vararg{Interpolations.Flag, N}}, Tuple{Vararg{AbstractVector{T} where T, N}}, Tuple{Vararg{Number, N}}}} where {F, N}"><code>Interpolations.weightedindexes</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; wis = Interpolations.weightedindexes((Interpolations.value_weights,), Interpolations.itpinfo(itp)..., x)
(Interpolations.WeightedAdjIndex{2, Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2, Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2, Float64}(1, (0.30000000000000004, 0.7)))

julia&gt; wis[1]
Interpolations.WeightedAdjIndex{2, Float64}(1, (0.8, 0.19999999999999996))

julia&gt; wis[2]
Interpolations.WeightedAdjIndex{2, Float64}(1, (0.6000000000000001, 0.3999999999999999))

julia&gt; wis[3]
Interpolations.WeightedAdjIndex{2, Float64}(1, (0.30000000000000004, 0.7))

julia&gt; Interpolations.InterpGetindex(A)[wis...]
8.7</code></pre><p>You can see that each of <code>wis</code> corresponds to a specific position: 1.2, 1.4, and 1.7 respectively. We can index <code>A</code> at <code>wis</code>, and it returns the value of <code>itp(x...)</code>, which here is just</p><pre><code class="nohighlight hljs">  0.8 * A[1, wis[2], wis[3]] + 0.2 * A[2, wis[2], wis[3]]
= 0.6 * (0.8 * A[1, 1, wis[3]] + 0.2 * A[2, 1, wis[3]]) +
  0.4 * (0.8 * A[1, 2, wis[3]] + 0.2 * A[2, 2, wis[3]])
= 0.3 * (0.6 * (0.8 * A[1, 1, 1] + 0.2 * A[2, 1, 1]) +
         0.4 * (0.8 * A[1, 2, 1] + 0.2 * A[2, 2, 1])  ) +
  0.7 * (0.6 * (0.8 * A[1, 1, 2] + 0.2 * A[2, 1, 2]) +
         0.4 * (0.8 * A[1, 2, 2] + 0.2 * A[2, 2, 2])  )</code></pre><p>This computed the value of <code>itp</code> at <code>x...</code> because we called <code>weightedindexes</code> with just a single function, <a href="../api/#Interpolations.value_weights"><code>Interpolations.value_weights</code></a> (meaning, &quot;the weights needed to compute the value&quot;).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Remember that prefiltering is not used for <code>Linear</code> interpolation. In a case where prefiltering is used, we would substitute <code>InterpGetindex(itp.coefs)[wis...]</code> for <code>InterpGetindex(A)[wis...]</code> above.</p></div></div><p>To compute derivatives, we <em>also</em> pass additional functions like <a href="../api/#Interpolations.gradient_weights"><code>Interpolations.gradient_weights</code></a>:</p><pre><code class="nohighlight hljs">julia&gt; wis = Interpolations.weightedindexes((Interpolations.value_weights, Interpolations.gradient_weights), Interpolations.itpinfo(itp)..., x)
((Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7))), (Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7))), (Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0))))

julia&gt; wis[1]
(Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7)))

julia&gt; wis[2]
(Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7)))

julia&gt; wis[3]
(Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)))

julia&gt; Interpolations.InterpGetindex(A)[wis[1]...]
1.0

julia&gt; Interpolations.InterpGetindex(A)[wis[2]...]
3.000000000000001

julia&gt; Interpolations.InterpGetindex(A)[wis[3]...]
9.0</code></pre><p>In this case you can see that <code>wis</code> is a 3-tuple-of-3-tuples. <code>A[wis[i]...]</code> can be used to compute the <code>i</code>th component of the gradient.</p><p>If you look carefully at each of the entries in <code>wis</code>, you&#39;ll see that each &quot;inner&quot; 3-tuple copies two of the three elements in the <code>wis</code> we obtained when we called <code>weightedindexes</code> with just <code>value_weights</code> above. <code>wis[1]</code> replaces the first entry with a weighted index having weights <code>(-1.0, 1.0)</code>, which corresponds to computing the <em>slope</em> along this dimension. Likewise <code>wis[2]</code> and <code>wis[3]</code> replace the second and third value-index, respectively, with the same slope computation.</p><p>Hessian computation is quite similar, with the difference that one sometimes needs to replace two different indices or the same index with a set of weights corresponding to a second derivative.</p><p>Consequently derivatives along particular directions are computed simply by &quot;weight replacement&quot; along the corresponding dimensions.</p><p>The code to do this replacement is a bit complicated due to the need to support arbitrary dimensionality in a manner that allows Julia&#39;s type-inference to succeed. It makes good use of <em>tuple</em> manipulations, sometimes called &quot;lispy tuple programming.&quot; You can search Julia&#39;s discourse forum for more tips about how to program this way. It could alternatively be done using generated functions, but this would increase compile time considerably and can lead to world-age problems.</p><h3 id="GPU-Support"><a class="docs-heading-anchor" href="#GPU-Support">GPU Support</a><a id="GPU-Support-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Support" title="Permalink"></a></h3><p>At present, <code>Interpolations.jl</code> supports interpolant usage on GPU via broadcasting.</p><p>A basic work flow looks like:</p><pre><code class="language-julia hljs">julia&gt; using Interpolations, Adapt, CUDA # Or any other GPU package

julia &gt; itp = Interpolations.interpolate([1, 2, 3], (BSpline(Linear()))); # construct the interpolant object on CPU

julia&gt; cuitp = adapt(CuArray{Float32}, itp); # adapt it to GPU memory

julia &gt; cuitp.(1:0.5:2) # call interpolant object via broadcast

julia&gt; gradient.(Ref(cuitp), 1:0.5:2)</code></pre><p>To achieve this, an <code>ITP &lt;: AbstractInterpolation</code> should define it&#39;s own <code>Adapt.adapt_structure(to, itp::ITP)</code>, which constructs a new <code>ITP</code> with the adapted fields (<code>adapt(to, itp.fieldname)</code>) of <code>itp</code>. The field adaption could be skipped if we know that it has been GPU-compatable, e.g. a <code>isbit</code> range.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Some adaptors may change the storage type. Please ensure that the adapted <code>itp</code> has the correct element type via the method <code>eltype</code>.</p></div></div><p>Also, all GPU-compatable <code>AbstractInterpolation</code>s should define their own <code>Interpolations.root_storage_type</code>. This function allows us to modify the broadcast mechanism by overloading the default <code>BroadcastStyle</code>. See <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interfaces-broadcasting">Customizing broadcasting</a> for more details.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../iterate/">« Knot Iteration</a><a class="docs-footer-nextpage" href="../api/">Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 23 June 2023 07:43">Friday 23 June 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
