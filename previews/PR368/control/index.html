<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interpolation algorithms · Interpolations.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Interpolations.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../interpolations/">General usage</a></li><li class="is-active"><a class="tocitem" href>Interpolation algorithms</a><ul class="internal"><li><a class="tocitem" href="#Control-of-interpolation-algorithm-1"><span>Control of interpolation algorithm</span></a></li><li><a class="tocitem" href="#Parametric-splines-1"><span>Parametric splines</span></a></li></ul></li><li><a class="tocitem" href="../extrapolation/">Extrapolation</a></li><li><a class="tocitem" href="../convenience-construction/">Convenience Constructors</a></li><li><a class="tocitem" href="../devdocs/">Developer documentation</a></li><li><a class="tocitem" href="../api/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interpolation algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interpolation algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/Interpolations.jl/blob/master/docs/src/control.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Control-of-interpolation-algorithm-1"><a class="docs-heading-anchor" href="#Control-of-interpolation-algorithm-1">Control of interpolation algorithm</a><a class="docs-heading-anchor-permalink" href="#Control-of-interpolation-algorithm-1" title="Permalink"></a></h2><h3 id="BSplines-1"><a class="docs-heading-anchor" href="#BSplines-1">BSplines</a><a class="docs-heading-anchor-permalink" href="#BSplines-1" title="Permalink"></a></h3><p>The interpolation type is described in terms of <em>degree</em> and, if necessary, <em>boundary conditions</em>. There are currently four degrees available: <code>Constant</code>, <code>Linear</code>, <code>Quadratic</code>,  and <code>Cubic</code> corresponding to B-splines of degree 0, 1, 2, and 3 respectively.</p><p>B-splines of quadratic or higher degree require solving an equation system to obtain the interpolation coefficients, and for that you must specify a <em>boundary condition</em> that is applied to close the system. The following boundary conditions are implemented: <code>Flat</code>, <code>Line</code> (alternatively, <code>Natural</code>), <code>Free</code>, <code>Periodic</code> and <code>Reflect</code>; their mathematical implications are described in detail in the pdf document under <code>/doc/latex</code>. When specifying these boundary conditions you also have to specify whether they apply at the edge grid point (<code>OnGrid()</code>) or beyond the edge point halfway to the next (fictitious) grid point (<code>OnCell()</code>).</p><p>Some examples:</p><pre><code class="language-julia"># Nearest-neighbor interpolation
itp = interpolate(a, BSpline(Constant()))
v = itp(5.4)   # returns a[5]

# (Multi)linear interpolation
itp = interpolate(A, BSpline(Linear()))
v = itp(3.2, 4.1)  # returns 0.9*(0.8*A[3,4]+0.2*A[4,4]) + 0.1*(0.8*A[3,5]+0.2*A[4,5])

# Quadratic interpolation with reflecting boundary conditions
# Quadratic is the lowest order that has continuous gradient
itp = interpolate(A, BSpline(Quadratic(Reflect(OnCell()))))

# Linear interpolation in the first dimension, and no interpolation (just lookup) in the second
itp = interpolate(A, (BSpline(Linear()), NoInterp()))
v = itp(3.65, 5)  # returns  0.35*A[3,5] + 0.65*A[4,5]</code></pre><p>There are more options available, for example:</p><pre><code class="language-julia"># In-place interpolation
itp = interpolate!(A, BSpline(Quadratic(InPlace(OnCell()))))</code></pre><p>which destroys the input <code>A</code> but also does not need to allocate as much memory.</p><h3 id="Scaled-BSplines-1"><a class="docs-heading-anchor" href="#Scaled-BSplines-1">Scaled BSplines</a><a class="docs-heading-anchor-permalink" href="#Scaled-BSplines-1" title="Permalink"></a></h3><p>BSplines assume your data is uniformly spaced on the grid <code>1:N</code>, or its multidimensional equivalent. If you have data of the form <code>[f(x) for x in A]</code>, you need to tell Interpolations about the grid <code>A</code>. If <code>A</code> is not uniformly spaced, you must use gridded interpolation described below. However, if <code>A</code> is a collection of ranges or linspaces, you can use scaled BSplines. This is more efficient because the gridded algorithm does not exploit the uniform spacing. Scaled BSplines can also be used with any spline degree available for BSplines, while gridded interpolation does not currently support quadratic or cubic splines.</p><p>Some examples,</p><pre><code class="language-julia">A_x = 1.:2.:40.
A = [log(x) for x in A_x]
itp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))
sitp = scale(itp, A_x)
sitp(3.) # exactly log(3.)
sitp(3.5) # approximately log(3.5)</code></pre><p>For multidimensional uniformly spaced grids</p><pre><code class="language-julia">A_x1 = 1:.1:10
A_x2 = 1:.5:20
f(x1, x2) = log(x1+x2)
A = [f(x1,x2) for x1 in A_x1, x2 in A_x2]
itp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))
sitp = scale(itp, A_x1, A_x2)
sitp(5., 10.) # exactly log(5 + 10)
sitp(5.6, 7.1) # approximately log(5.6 + 7.1)</code></pre><h3 id="Gridded-interpolation-1"><a class="docs-heading-anchor" href="#Gridded-interpolation-1">Gridded interpolation</a><a class="docs-heading-anchor-permalink" href="#Gridded-interpolation-1" title="Permalink"></a></h3><p>These use a very similar syntax to BSplines, with the major exception being that one does not get to choose the grid representation (they are all <code>OnGrid</code>). As such one must specify a set of coordinate arrays defining the nodes of the array.</p><p>In 1D</p><pre><code class="language-julia">A = rand(20)
A_x = 1.0:2.0:40.0
nodes = (A_x,)
itp = interpolate(nodes, A, Gridded(Linear()))
itp(2.0)</code></pre><p>The spacing between adjacent samples need not be constant; indeed, if they are constant, you&#39;ll get better performance with <code>scaled</code>.</p><p>The general syntax is</p><pre><code class="language-julia">itp = interpolate(nodes, A, options...)</code></pre><p>where <code>nodes = (xnodes, ynodes, ...)</code> specifies the positions along each axis at which the array <code>A</code> is sampled for arbitrary (&quot;rectangular&quot;) samplings.</p><p>For example:</p><pre><code class="language-julia">A = rand(8,20)
nodes = ([x^2 for x = 1:8], [0.2y for y = 1:20])
itp = interpolate(nodes, A, Gridded(Linear()))
itp(4,1.2)  # approximately A[2,6]</code></pre><p>One may also mix modes, by specifying a mode vector in the form of an explicit tuple:</p><pre><code class="language-julia">itp = interpolate(nodes, A, (Gridded(Linear()),Gridded(Constant())))</code></pre><p>Presently there are only three modes for gridded:</p><pre><code class="language-julia">Gridded(Linear())</code></pre><p>whereby a linear interpolation is applied between nodes,</p><pre><code class="language-julia">Gridded(Constant())</code></pre><p>whereby nearest neighbor interpolation is used on the applied axis,</p><pre><code class="language-julia">NoInterp()</code></pre><p>whereby the coordinate of the selected input vector MUST be located on a grid point. Requests for off grid coordinates results in the throwing of an error.</p><p><code>missing</code> data will naturally propagate through the interpolation, where some values will become missing. To avoid that, one can filter out the missing data points and use a gridded interpolation. For example:</p><pre><code class="language-julia">x = 1:6
A = [i == 3 ? missing : i for i in x]
xf = [xi for (xi,a) in zip(x, A) if !ismissing(a)]
Af = [a for a in A if !ismissing(a)]
itp = interpolate((xf, ), Af, Gridded(Linear()))</code></pre><h2 id="Parametric-splines-1"><a class="docs-heading-anchor" href="#Parametric-splines-1">Parametric splines</a><a class="docs-heading-anchor-permalink" href="#Parametric-splines-1" title="Permalink"></a></h2><p>Given a set a knots with coordinates <code>x(t)</code> and <code>y(t)</code>, a parametric spline <code>S(t) = (x(t),y(t))</code> parametrized by <code>t in [0,1]</code> can be constructed with the following code adapted from a <a href="http://julia-programming-language.2336112.n4.nabble.com/Parametric-splines-td37794.html#a37818">post</a> by Tomas Lycken:</p><pre><code class="language-julia">using Interpolations

t = 0:.1:1
x = sin.(2π*t)
y = cos.(2π*t)
A = hcat(x,y)

itp = Interpolations.scale(interpolate(A, (BSpline(Cubic(Natural(OnGrid()))), NoInterp())), t, 1:2)

tfine = 0:.01:1
xs, ys = [itp(t,1) for t in tfine], [itp(t,2) for t in tfine]</code></pre><p>We can then plot the spline with:</p><pre><code class="language-julia">using Plots

scatter(x, y, label=&quot;knots&quot;)
plot!(xs, ys, label=&quot;spline&quot;)</code></pre><p><img src="doc/images/parametric_spline.png" alt="parametric spline"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interpolations/">« General usage</a><a class="docs-footer-nextpage" href="../extrapolation/">Extrapolation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 26 May 2020 16:29">Tuesday 26 May 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
