<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Interpolations.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Interpolations.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../interpolations/">General usage</a></li><li><a class="tocitem" href="../control/">Interpolation algorithms</a></li><li><a class="tocitem" href="../extrapolation/">Extrapolation</a></li><li><a class="tocitem" href="../convenience-construction/">Convenience Constructors</a></li><li><a class="tocitem" href="../devdocs/">Developer documentation</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Public-API-1"><span>Public API</span></a></li><li><a class="tocitem" href="#Internal-API-1"><span>Internal API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/Interpolations.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Public-API-1"><a class="docs-heading-anchor" href="#Public-API-1">Public API</a><a class="docs-heading-anchor-permalink" href="#Public-API-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Interpolations.CubicSplineInterpolation" href="#Interpolations.CubicSplineInterpolation"><code>Interpolations.CubicSplineInterpolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">etp = CubicSplineInterpolation(knots, A; bc=Line(OnGrid()), extrapolation_bc=Throw())</code></pre><p>A shorthand for <code>extrapolate(interpolate(knots, A, BSpline(Cubic(bc))), extrapolation_bc)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/convenience-constructors.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.LinearInterpolation" href="#Interpolations.LinearInterpolation"><code>Interpolations.LinearInterpolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">etp = LinearInterpolation(knots, A; extrapolation_bc=Throw())</code></pre><p>A shorthand for <code>extrapolate(interpolate(knots, A, scheme), extrapolation_bc)</code>, where <code>scheme</code> is either <code>BSpline(Linear())</code> or <code>Gridded(Linear())</code> depending on whether <code>knots</code> are ranges or vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/convenience-constructors.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.bounds-Tuple{AbstractInterpolation}" href="#Interpolations.bounds-Tuple{AbstractInterpolation}"><code>Interpolations.bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bounds(itp::AbstractInterpolation)</code></pre><p>Return the <code>bounds</code> of the domain of <code>itp</code> as a tuple of <code>(min, max)</code> pairs for each coordinate. This is best explained by example:</p><pre><code class="language-julia-repl">julia&gt; itp = interpolate([1 2 3; 4 5 6], BSpline(Linear()));

julia&gt; bounds(itp)
((1, 2), (1, 3))

julia&gt; data = 1:3;

julia&gt; knots = ([10, 11, 13.5],);

julia&gt; itp = interpolate(knots, data, Gridded(Linear()));

julia&gt; bounds(itp)
((10.0, 13.5),)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L119-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.extrapolate-Union{Tuple{ET}, Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},ET}} where ET&lt;:Union{Tuple{Vararg{Union{Tuple{BoundaryCondition,BoundaryCondition}, BoundaryCondition},N} where N}, BoundaryCondition} where IT where N where T" href="#Interpolations.extrapolate-Union{Tuple{ET}, Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},ET}} where ET&lt;:Union{Tuple{Vararg{Union{Tuple{BoundaryCondition,BoundaryCondition}, BoundaryCondition},N} where N}, BoundaryCondition} where IT where N where T"><code>Interpolations.extrapolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>extrapolate(itp, scheme)</code> adds extrapolation behavior to an interpolation object, according to the provided scheme.</p><p>The scheme can take any of these values:</p><ul><li><code>Throw</code> - throws a BoundsError for out-of-bounds indices</li><li><code>Flat</code> - for constant extrapolation, taking the closest in-bounds value</li><li><code>Line</code> - linear extrapolation (the wrapped interpolation object must support gradient)</li><li><code>Reflect</code> - reflecting extrapolation (indices must support <code>mod</code>)</li><li><code>Periodic</code> - periodic extrapolation (indices must support <code>mod</code>)</li></ul><p>You can also combine schemes in tuples. For example, the scheme <code>(Line(), Flat())</code> will use linear extrapolation in the first dimension, and constant in the second.</p><p>Finally, you can specify different extrapolation behavior in different direction. <code>((Line(),Flat()), Flat())</code> will extrapolate linearly in the first dimension if the index is too small, but use constant etrapolation if it is too large, and always use constant extrapolation in the second dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/extrapolation/extrapolation.jl#L25-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.extrapolate-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},Any}} where IT where N where T" href="#Interpolations.extrapolate-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},Any}} where IT where N where T"><code>Interpolations.extrapolate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>extrapolate(itp, fillvalue)</code> creates an extrapolation object that returns the <code>fillvalue</code> any time the indexes in <code>itp(x1,x2,...)</code> are out-of-bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/extrapolation/filled.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray,IT}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline},N} where N}, BSpline}" href="#Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray,IT}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline},N} where N}, BSpline}"><code>Interpolations.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">itp = interpolate(A, interpmode)</code></pre><p>Interpolate an array <code>A</code> in the mode determined by <code>interpmode</code>. <code>interpmode</code> may be one of</p><ul><li><code>NoInterp()</code></li><li><code>BSpline(Constant())</code></li><li><code>BSpline(Linear())</code></li><li><code>BSpline(Quadratic(bc))</code> (see <a href="#Interpolations.BoundaryCondition"><code>BoundaryCondition</code></a>)</li><li><code>BSpline(Cubic(bc))</code></li></ul><p>It may also be a tuple of such values, if you want to use different interpolation schemes along each axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/b-splines.jl#L164-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.interpolate-Union{Tuple{IT}, Tuple{N}, Tuple{Tel}, Tuple{Tuple{Vararg{Union{AbstractArray{T,1}, Tuple} where T,N}},AbstractArray{Tel,N},IT}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded},N} where N}, Gridded} where N where Tel" href="#Interpolations.interpolate-Union{Tuple{IT}, Tuple{N}, Tuple{Tel}, Tuple{Tuple{Vararg{Union{AbstractArray{T,1}, Tuple} where T,N}},AbstractArray{Tel,N},IT}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded},N} where N}, Gridded} where N where Tel"><code>Interpolations.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">itp = interpolate((nodes1, nodes2, ...), A, interpmode)</code></pre><p>Interpolate an array <code>A</code> on a non-uniform but rectangular grid specified by the given <code>nodes</code>, in the mode determined by <code>interpmode</code>.</p><p><code>interpmode</code> may be one of</p><ul><li><code>NoInterp()</code></li><li><code>Gridded(Constant())</code></li><li><code>Gridded(Linear())</code></li></ul><p>It may also be a tuple of such values, if you want to use different interpolation schemes along each axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/gridded/gridded.jl#L69-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.scale-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},Vararg{AbstractRange,N}}} where IT where N where T" href="#Interpolations.scale-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},Vararg{AbstractRange,N}}} where IT where N where T"><code>Interpolations.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>scale(itp, xs, ys, ...)</code> scales an existing interpolation object to allow for indexing using other coordinate axes than unit ranges, by wrapping the interpolation object and transforming the indices from the provided axes onto unit ranges upon indexing.</p><p>The parameters <code>xs</code> etc must be either ranges or linspaces, and there must be one coordinate range/linspace for each dimension of the interpolation object.</p><p>For every <code>NoInterp</code> dimension of the interpolation object, the range must be exactly <code>1:size(itp, d)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/scaling/scaling.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.BSpline" href="#Interpolations.BSpline"><code>Interpolations.BSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSpline(degree)</code></pre><p>A flag signaling <code>BSpline</code> (integer-grid b-spline) interpolation along the corresponding axis. <code>degree</code> is one of <a href="#Interpolations.Constant"><code>Constant</code></a>, <a href="#Interpolations.Linear"><code>Linear</code></a>, <a href="#Interpolations.Quadratic"><code>Quadratic</code></a>, or <a href="#Interpolations.Cubic"><code>Cubic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/b-splines.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.CardinalMonotonicInterpolation" href="#Interpolations.CardinalMonotonicInterpolation"><code>Interpolations.CardinalMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CardinalMonotonicInterpolation(tension)</code></pre><p>Cubic cardinal splines, uses <code>tension</code> parameter which must be between [0,1] Cubin cardinal splines can overshoot for non-monotonic data (increasing tension reduces overshoot).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/monotonic/monotonic.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Constant" href="#Interpolations.Constant"><code>Interpolations.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Constant b-splines are <em>nearest-neighbor</em> interpolations, and effectively return <code>A[round(Int,x)]</code> when interpolating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/constant.jl#L3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Cubic" href="#Interpolations.Cubic"><code>Interpolations.Cubic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cubic(bc::BoundaryCondition)</code></pre><p>Indicate that the corresponding axis should use cubic interpolation.</p><p><strong>Extended help</strong></p><p>Assuming uniform knots with spacing 1, the <code>i</code>th piece of cubic spline implemented here is defined as follows.</p><pre><code class="language-none">y_i(x) = cm p(x-i) + c q(x-i) + cp q(1- (x-i)) + cpp p(1 - (x-i))</code></pre><p>where</p><pre><code class="language-none">p(δx) = 1/6 * (1-δx)^3
q(δx) = 2/3 - δx^2 + 1/2 δx^3</code></pre><p>and the values <code>cX</code> for <code>X ∈ {m, _, p, pp}</code> are the pre-filtered coefficients.</p><p>For future reference, this expands out to the following polynomial:</p><pre><code class="language-none">y_i(x) = 1/6 cm (1+i-x)^3 + c (2/3 - (x-i)^2 + 1/2 (x-i)^3) +
         cp (2/3 - (1+i-x)^2 + 1/2 (1+i-x)^3) + 1/6 cpp (x-i)^3</code></pre><p>When we derive boundary conditions we will use derivatives <code>y_0&#39;(x)</code> and <code>y_0&#39;&#39;(x)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/cubic.jl#L7-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.FiniteDifferenceMonotonicInterpolation" href="#Interpolations.FiniteDifferenceMonotonicInterpolation"><code>Interpolations.FiniteDifferenceMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FiniteDifferenceMonotonicInterpolation</code></pre><p>Classic cubic interpolation, no tension parameter. Finite difference can overshoot for non-monotonic data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/monotonic/monotonic.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Flat" href="#Interpolations.Flat"><code>Interpolations.Flat</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Flat(gt)</code> sets the extrapolation slope to zero</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.FritschButlandMonotonicInterpolation" href="#Interpolations.FritschButlandMonotonicInterpolation"><code>Interpolations.FritschButlandMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FritschButlandMonotonicInterpolation</code></pre><p>Monotonic interpolation based on  Fritsch &amp; Butland (1984), &quot;A Method for Constructing Local Monotone Piecewise Cubic Interpolants&quot;, doi:10.1137/0905021.</p><p>Faster than FritschCarlsonMonotonicInterpolation (only requires one pass) but somewhat higher apparent &quot;tension&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/monotonic/monotonic.jl#L79-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.FritschCarlsonMonotonicInterpolation" href="#Interpolations.FritschCarlsonMonotonicInterpolation"><code>Interpolations.FritschCarlsonMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FritschCarlsonMonotonicInterpolation</code></pre><p>Monotonic interpolation based on Fritsch &amp; Carlson (1980), &quot;Monotone Piecewise Cubic Interpolation&quot;, doi:10.1137/0717021.</p><p>Tangents are first initialized, then adjusted if they are not monotonic can overshoot for non-monotonic data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/monotonic/monotonic.jl#L67-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.InPlace" href="#Interpolations.InPlace"><code>Interpolations.InPlace</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>InPlace(gt)</code> is a boundary condition that allows prefiltering to occur in-place (it typically requires padding)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.InPlaceQ" href="#Interpolations.InPlaceQ"><code>Interpolations.InPlaceQ</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>InPlaceQ(gt)</code> is similar to <code>InPlace(gt)</code>, but is exact when the values being interpolated arise from an underlying quadratic. It is primarily useful for testing purposes, allowing near-exact (to machine precision) comparisons against ground truth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L97-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Lanczos" href="#Interpolations.Lanczos"><code>Interpolations.Lanczos</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lanczos{N}(a=4)</code></pre><p>Lanczos resampling via a kernel with scale parameter <code>a</code> and support over <code>N</code> neighbors.</p><p>This form of interpolation is merely the discrete convolution of the samples with a Lanczos kernel of size <code>a</code>. The size is directly related to how &quot;far&quot; the interpolation will reach for information, and has <code>O(N^2)</code> impact on runtime. An alternative implementation matching <code>lanczos4</code> from OpenCV is available as Lanczos4OpenCV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/lanczos/lanczos.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Lanczos4OpenCV" href="#Interpolations.Lanczos4OpenCV"><code>Interpolations.Lanczos4OpenCV</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lanczos4OpenCV()</code></pre><p>Alternative implementation of Lanczos resampling using algorithm <code>lanczos4</code> function of OpenCV: https://github.com/opencv/opencv/blob/de15636724967faf62c2d1bce26f4335e4b359e5/modules/imgproc/src/resize.cpp#L917-L946</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/lanczos/lanczos.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Line" href="#Interpolations.Line"><code>Interpolations.Line</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Line(gt)</code> uses a constant slope for extrapolation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Linear" href="#Interpolations.Linear"><code>Interpolations.Linear</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Linear()</code></pre><p>Indicate that the corresponding axis should use linear interpolation.</p><p><strong>Extended help</strong></p><p>Assuming uniform knots with spacing 1, the <code>i</code>th piece of linear b-spline implemented here is defined as follows.</p><pre><code class="language-none">y_i(x) = c p(x) + cp p(1-x)</code></pre><p>where</p><pre><code class="language-none">p(δx) = x</code></pre><p>and the values <code>cX</code> for <code>X ∈ {_, p}</code> are the coefficients.</p><p>Linear b-splines are naturally interpolating, and require no prefiltering; there is therefore no need for boundary conditions to be provided.</p><p>Also, although the implementation is slightly different in order to re-use the framework built for general b-splines, the resulting interpolant is just a piecewise linear function connecting each pair of neighboring data points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/linear.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.LinearMonotonicInterpolation" href="#Interpolations.LinearMonotonicInterpolation"><code>Interpolations.LinearMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearMonotonicInterpolation</code></pre><p>Simple linear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/monotonic/monotonic.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.NoInterp" href="#Interpolations.NoInterp"><code>Interpolations.NoInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>NoInterp()</code> indicates that the corresponding axis must use integer indexing (no interpolation is to be performed)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.OnCell" href="#Interpolations.OnCell"><code>Interpolations.OnCell</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>OnCell()</code> indicates that the boundary condition applies a half-gridspacing beyond the first &amp; last nodes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.OnGrid" href="#Interpolations.OnGrid"><code>Interpolations.OnGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>OnGrid()</code> indicates that the boundary condition applies at the first &amp; last nodes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Periodic" href="#Interpolations.Periodic"><code>Interpolations.Periodic</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Periodic(gt)</code> applies periodic boundary conditions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Quadratic" href="#Interpolations.Quadratic"><code>Interpolations.Quadratic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Quadratic(bc::BoundaryCondition)</code></pre><p>Indicate that the corresponding axis should use quadratic interpolation.</p><p><strong>Extended help</strong></p><p>Assuming uniform knots with spacing 1, the <code>i</code>th piece of quadratic spline implemented here is defined as follows:</p><pre><code class="language-none">y_i(x) = cm p(x-i) + c q(x) + cp p(1-(x-i))</code></pre><p>where</p><pre><code class="language-none">p(δx) = (δx - 1)^2 / 2
q(δx) = 3/4 - δx^2</code></pre><p>and the values for <code>cX</code> for <code>X ∈ {m,_,p}</code> are the pre-filtered coefficients.</p><p>For future reference, this expands to the following polynomial:</p><pre><code class="language-none">y_i(x) = cm * 1/2 * (x-i-1)^2 + c * (3/4 - x + i)^2 + cp * 1/2 * (x-i)^2</code></pre><p>When we derive boundary conditions we will use derivatives <code>y_1&#39;(x-1)</code> and <code>y_1&#39;&#39;(x-1)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/quadratic.jl#L7-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Reflect" href="#Interpolations.Reflect"><code>Interpolations.Reflect</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Reflect(gt)</code> applies reflective boundary conditions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.SteffenMonotonicInterpolation" href="#Interpolations.SteffenMonotonicInterpolation"><code>Interpolations.SteffenMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SteffenMonotonicInterpolation</code></pre><p>Monotonic interpolation based on Steffen (1990), &quot;A Simple Method for Monotonic Interpolation in One Dimension&quot;, http://adsabs.harvard.edu/abs/1990A%26A...239..443S</p><p>Only one pass, results usually between FritschCarlson and FritschButland.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/monotonic/monotonic.jl#L92-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.Throw" href="#Interpolations.Throw"><code>Interpolations.Throw</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Throw(gt)</code> causes beyond-the-edge extrapolation to throw an error</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L84">source</a></section></article><h2 id="Internal-API-1"><a class="docs-heading-anchor" href="#Internal-API-1">Internal API</a><a class="docs-heading-anchor-permalink" href="#Internal-API-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Interpolations.boundstep" href="#Interpolations.boundstep"><code>Interpolations.boundstep</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <em>half</em> the width of one step of the range.</p><p>This function is used to calculate the upper and lower bounds of <code>OnCell</code> interpolation objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/scaling/scaling.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.count_interp_dims-Union{Tuple{Type{ITP}}, Tuple{ITP}} where ITP&lt;:AbstractInterpolation" href="#Interpolations.count_interp_dims-Union{Tuple{Type{ITP}}, Tuple{ITP}} where ITP&lt;:AbstractInterpolation"><code>Interpolations.count_interp_dims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">n = count_interp_dims(ITP)</code></pre><p>Count the number of dimensions along which type <code>ITP</code> is interpolating. <code>NoInterp</code> dimensions do not contribute to the sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.gradient_weights" href="#Interpolations.gradient_weights"><code>Interpolations.gradient_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">w = gradient_weights(degree, δx)</code></pre><p>Compute the weights for interpolation of the gradient at an offset <code>δx</code> from the &quot;base&quot; position. <code>degree</code> describes the interpolation scheme.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Interpolations.gradient_weights(Linear(), 0.2)
(-1.0, 1.0)</code></pre><p>This defines the gradient of a linear interpolation at 3.2 as <code>y[4] - y[3]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L358-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.hessian_weights" href="#Interpolations.hessian_weights"><code>Interpolations.hessian_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">w = hessian_weights(degree, δx)</code></pre><p>Compute the weights for interpolation of the hessian at an offset <code>δx</code> from the &quot;base&quot; position. <code>degree</code> describes the interpolation scheme.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Interpolations.hessian_weights(Linear(), 0.2)
(0.0, 0.0)</code></pre><p>Linear interpolation uses straight line segments, so the second derivative is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L375-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.inner_system_diags" href="#Interpolations.inner_system_diags"><code>Interpolations.inner_system_diags</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dl, d, du = inner_system_diags{T,IT}(::Type{T}, n::Int, ::Type{IT})</code></pre><p>Helper function to generate the prefiltering equation system: generates the diagonals for a <code>n</code>-by-<code>n</code> tridiagonal matrix with eltype <code>T</code> corresponding to the interpolation type <code>IT</code>.</p><p><code>dl</code>, <code>d</code>, and <code>du</code> are intended to be used e.g. as in <code>M = Tridiagonal(dl, d, du)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/prefiltering.jl#L100-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.inner_system_diags-Union{Tuple{T}, Tuple{Type{T},Int64,Cubic}} where T" href="#Interpolations.inner_system_diags-Union{Tuple{T}, Tuple{Type{T},Int64,Cubic}} where T"><code>Interpolations.inner_system_diags</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic</code>: continuity in function value, first and second derivatives yields</p><pre><code class="language-none">2/3 1/6
1/6 2/3 1/6
    1/6 2/3 1/6
       ⋱  ⋱   ⋱</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/cubic.jl#L77-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.lanczos-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Any}} where T" href="#Interpolations.lanczos-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Any}} where T"><code>Interpolations.lanczos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lanczos(x, a, n=a)</code></pre><p>Implementation of the <a href="https://en.wikipedia.org/wiki/Lanczos_resampling">Lanczos kernel</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/lanczos/lanczos.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system" href="#Interpolations.prefiltering_system"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">M, b = prefiltering_system{T,TC,GT&lt;:GridType,D&lt;:Degree}m(::T, ::Type{TC}, n::Int, ::Type{D}, ::Type{GT})</code></pre><p>Given element types (<code>T</code>, <code>TC</code>) and interpolation scheme (<code>GT</code>, <code>D</code>) as well the number of rows in the data input (<code>n</code>), compute the system used to prefilter spline coefficients. Boundary conditions determine the values on the first and last rows.</p><p>Some of these boundary conditions require that these rows have off-tridiagonal elements (e.g the <code>[1,3]</code> element of the matrix). To maintain the efficiency of solving tridiagonal systems, the <a href="https://en.wikipedia.org/wiki/Woodbury_matrix_identity">Woodbury matrix identity</a> is used to add additional elements off the main 3 diagonals.</p><p>The filtered coefficients are given by solving the equation system</p><pre><code class="language-none">M * c = v + b</code></pre><p>where <code>c</code> are the sought coefficients, and <code>v</code> are the data points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/prefiltering.jl#L79-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{BC}}} where BC&lt;:Union{Flat{OnCell}, Reflect{OnCell}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{BC}}} where BC&lt;:Union{Flat{OnCell}, Reflect{OnCell}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Quadratic{Flat}</code> <code>OnCell</code> and <code>Quadratic{Reflect}</code> <code>OnCell</code> amounts to setting <code>y_1&#39;(x) = 0</code> at x=1/2. Applying this condition yields</p><pre><code class="language-none">-cm + c = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/quadratic.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{BC}}} where BC&lt;:Union{Flat{OnGrid}, Reflect{OnGrid}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{BC}}} where BC&lt;:Union{Flat{OnGrid}, Reflect{OnGrid}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Quadratic{Flat}</code> <code>OnGrid</code> and <code>Quadratic{Reflect}</code> <code>OnGrid</code> amount to setting <code>y_1&#39;(x) = 0</code> at <code>x=1</code>. Applying this condition yields</p><pre><code class="language-none">-cm + cp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/quadratic.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{#s12} where #s12&lt;:Free}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{#s12} where #s12&lt;:Free}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Free}</code> <code>OnGrid</code> and <code>Cubic{Free}</code> <code>OnCell</code> amount to requiring an extra continuous derivative at the second-to-last cell boundary; this means <code>y_1&#39;&#39;&#39;(2) = y_2&#39;&#39;&#39;(2)</code>, yielding</p><pre><code class="language-none">1 cm -3 c + 3 cp -1 cpp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/cubic.jl#L214-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{#s12} where #s12&lt;:Periodic}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{#s12} where #s12&lt;:Periodic}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Periodic}</code> <code>OnGrid</code> closes the system by looking at the coefficients themselves as periodic, yielding</p><pre><code class="language-none">c0 = c(N+1)</code></pre><p>where <code>N</code> is the number of data points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/cubic.jl#L194-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Flat{OnCell}}}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Flat{OnCell}}}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Flat}</code>, <code>OnCell</code> amounts to setting <code>y_1&#39;(x) = 0</code> at <code>x = 1/2</code>. Applying this condition yields</p><pre><code class="language-none">-9/8 cm + 11/8 c - 3/8 cp + 1/8 cpp = 0</code></pre><p>or, equivalently,</p><pre><code class="language-none">-9 cm + 11 c -3 cp + 1 cpp = 0</code></pre><p>(Note that we use <code>y_1&#39;(x)</code> although it is strictly not valid in this domain; if we were to use <code>y_0&#39;(x)</code> we would have to introduce new coefficients, so that would not close the system. Instead, we extend the outermost polynomial for an extra half-cell.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/cubic.jl#L110-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Flat{OnGrid}}}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Flat{OnGrid}}}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Flat}</code> <code>OnGrid</code> amounts to setting <code>y_1&#39;(x) = 0</code> at <code>x = 1</code>. Applying this condition yields</p><pre><code class="language-none">-cm + cp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/cubic.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Line{OnCell}}}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Line{OnCell}}}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Line}</code> <code>OnCell</code> amounts to setting <code>y_1&#39;&#39;(x) = 0</code> at <code>x = 1/2</code>. Applying this condition yields</p><pre><code class="language-none">3 cm -7 c + 5 cp -1 cpp = 0</code></pre><p>(Note that we use <code>y_1&#39;(x)</code> although it is strictly not valid in this domain; if we were to use <code>y_0&#39;(x)</code> we would have to introduce new coefficients, so that would not close the system. Instead, we extend the outermost polynomial for an extra half-cell.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/cubic.jl#L143-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Line{OnGrid}}}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Line{OnGrid}}}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Cubic{Line}</code> <code>OnGrid</code> amounts to setting <code>y_1&#39;&#39;(x) = 0</code> at <code>x = 1</code>. Applying this condition gives:</p><pre><code class="language-none">1 cm -2 c + 1 cp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/cubic.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Free}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Free}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Quadratic{Free}</code> <code>OnGrid</code> and <code>Quadratic{Free}</code> <code>OnCell</code> amount to requiring an extra continuous derivative at the second-to-last cell boundary; this means that <code>y_1&#39;&#39;(3/2) = y_2&#39;&#39;(3/2)</code>, yielding</p><pre><code class="language-none">1 cm -3 c + 3 cp - cpp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/quadratic.jl#L147-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Line}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Line}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Quadratic{Line}</code> <code>OnGrid</code> and <code>Quadratic{Line}</code> <code>OnCell</code> amount to setting <code>y_1&#39;&#39;(x) = 0</code> at <code>x=1</code> and <code>x=1/2</code> respectively. Since <code>y_i&#39;&#39;(x)</code> is independent of <code>x</code> for a quadratic b-spline, these both yield</p><pre><code class="language-none">1 cm -2 c + 1 cp = 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/quadratic.jl#L127-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Periodic}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Periodic}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Quadratic{Periodic}</code> <code>OnGrid</code> and <code>Quadratic{Periodic}</code> <code>OnCell</code> close the system by looking at the coefficients themselves as periodic, yielding</p><pre><code class="language-none">c0 = c(N+1)</code></pre><p>where <code>N</code> is the number of data points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/quadratic.jl#L168-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.rescale_gradient" href="#Interpolations.rescale_gradient"><code>Interpolations.rescale_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>rescale_gradient(r::AbstractRange)</code></p><p>Implements the chain rule dy/dx = dy/du * du/dx for use when calculating gradients with scaled interpolation objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/scaling/scaling.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.show_ranged-Tuple{IO,Any,Any}" href="#Interpolations.show_ranged-Tuple{IO,Any,Any}"><code>Interpolations.show_ranged</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show_ranged(io, X, knots)</code></pre><p>A replacement for the default array-<code>show</code> for types that may not have the canonical evaluation points. <code>rngs</code> is the tuple of knots along each axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/io.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.value_weights" href="#Interpolations.value_weights"><code>Interpolations.value_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">w = value_weights(degree, δx)</code></pre><p>Compute the weights for interpolation of the value at an offset <code>δx</code> from the &quot;base&quot; position. <code>degree</code> describes the interpolation scheme.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Interpolations.value_weights(Linear(), 0.2)
(0.8, 0.2)</code></pre><p>This corresponds to the fact that linear interpolation at <code>x + 0.2</code> is <code>0.8*y[x] + 0.2*y[x+1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L341-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.weightedindexes-Union{Tuple{N}, Tuple{F}, Tuple{F,Tuple{Vararg{Flag,N}},Tuple{Vararg{AbstractArray{T,1} where T,N}},Tuple{Vararg{Number,N}}}} where N where F" href="#Interpolations.weightedindexes-Union{Tuple{N}, Tuple{F}, Tuple{F,Tuple{Vararg{Flag,N}},Tuple{Vararg{AbstractArray{T,1} where T,N}},Tuple{Vararg{Number,N}}}} where N where F"><code>Interpolations.weightedindexes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">weightedindexes(fs, itpflags, nodes, xs)</code></pre><p>Compute <code>WeightedIndex</code> values for evaluation at the position <code>xs...</code>. <code>fs</code> is a function or tuple of functions indicating the types of index required, typically <code>value_weights</code>, <code>gradient_weights</code>, and/or <code>hessian_weights</code>. <code>itpflags</code> and <code>nodes</code> can be obtained from <code>itpinfo(itp)...</code>.</p><p>See the &quot;developer documentation&quot; for further information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/indexing.jl#L54-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.BSplineInterpolation" href="#Interpolations.BSplineInterpolation"><code>Interpolations.BSplineInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSplineInterpolation{T,N,TCoefs,IT,Axs}</code></pre><p>An interpolant-type for b-spline interpolation on a uniform grid with integer nodes. <code>T</code> indicates the element type for operations like <code>collect(itp)</code>, and may also agree with the values obtained from <code>itp(x, y, ...)</code> at least for certain types of <code>x</code> and <code>y</code>. <code>N</code> is the dimensionality of the interpolant. The remaining type-parameters describe the types of fields:</p><ul><li>the <code>coefs</code> field holds the interpolation coefficients. Depending on prefiltering, these may or may not be the same as the supplied array of interpolant values.</li><li><code>parentaxes</code> holds the axes of the parent. Depending on prefiltering this may be &quot;narrower&quot; than the axes of <code>coefs</code>.</li><li><code>it</code> holds the interpolation type, e.g., <code>BSpline(Linear())</code> or <code>(BSpline(Quadratic(OnCell()),BSpline(Linear()))</code>.</li></ul><p><code>BSplineInterpolation</code> objects are typically created with <a href="#Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray,IT}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline},N} where N}, BSpline}"><code>interpolate</code></a>. However, for customized control you may also construct them with</p><pre><code class="language-none">BSplineInterpolation(TWeights, coefs, it, axs)</code></pre><p>where <code>T</code> gets computed from the product of <code>TWeights</code> and <code>eltype(coefs)</code>. (This is equivalent to indicating that you&#39;ll be evaluating at locations <code>itp(x::TWeights, y::TWeights, ...)</code>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/b-splines/b-splines.jl#L47-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.BoundaryCondition" href="#Interpolations.BoundaryCondition"><code>Interpolations.BoundaryCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoundaryCondition</code></pre><p>An abstract type with one of the following values (see the help for each for details):</p><ul><li><code>Throw(gt)</code></li><li><code>Flat(gt)</code></li><li><code>Line(gt)</code></li><li><code>Free(gt)</code></li><li><code>Periodic(gt)</code></li><li><code>Reflect(gt)</code></li><li><code>InPlace(gt)</code></li><li><code>InPlaceQ(gt)</code></li></ul><p>where <code>gt</code> is the grid type, e.g., <a href="#Interpolations.OnGrid"><code>OnGrid()</code></a> or <a href="#Interpolations.OnCell"><code>OnCell()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L65-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.BoundsCheckStyle" href="#Interpolations.BoundsCheckStyle"><code>Interpolations.BoundsCheckStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoundsCheckStyle(itp)</code></pre><p>A trait to determine dispatch of bounds-checking for <code>itp</code>. Can return <code>NeedsCheck()</code>, in which case bounds-checking is performed, or <code>CheckWillPass()</code> in which case the check will return <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L170-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.LanczosInterpolation" href="#Interpolations.LanczosInterpolation"><code>Interpolations.LanczosInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LanczosInterpolation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/lanczos/lanczos.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.MonotonicInterpolation" href="#Interpolations.MonotonicInterpolation"><code>Interpolations.MonotonicInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MonotonicInterpolation</code></pre><p>Monotonic interpolation up to third order represented by type, knots and coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/monotonic/monotonic.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.MonotonicInterpolationType" href="#Interpolations.MonotonicInterpolationType"><code>Interpolations.MonotonicInterpolationType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MonotonicInterpolationType</code></pre><p>Abstract class for all types of monotonic interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/monotonic/monotonic.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Interpolations.WeightedIndex" href="#Interpolations.WeightedIndex"><code>Interpolations.WeightedIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">wi = WeightedIndex(indexes, weights)</code></pre><p>Construct a weighted index <code>wi</code>, which can be thought of as a generalization of an ordinary array index to the context of interpolation. For an ordinary vector <code>a</code>, <code>a[i]</code> extracts the element at index <code>i</code>. When interpolating, one is typically interested in a range of indexes and the output is some weighted combination of array values at these indexes. For example, for linear interpolation at a location <code>x</code> between integers <code>i</code> and <code>i+1</code>, we have</p><pre><code class="language-none">ret = (1-f)*a[i] + f*a[i+1]</code></pre><p>where <code>f = x-i</code> lies between 0 and 1. This can be represented as <code>a[wi]</code>, where</p><pre><code class="language-none">wi = WeightedIndex(i:i+1, (1-f, f))</code></pre><p>i.e.,</p><pre><code class="language-none">ret = sum(a[indexes] .* weights)</code></pre><p>Linear interpolation thus constructs weighted indices using a 2-tuple for <code>weights</code> and a length-2 <code>indexes</code> range. Higher-order interpolation would involve more positions and weights (e.g., 3-tuples for quadratic interpolation, 4-tuples for cubic).</p><p>In multiple dimensions, separable interpolation schemes are implemented in terms of multiple weighted indices, accessing <code>A[wi1, wi2, ...]</code> where each <code>wi</code> is the <code>WeightedIndex</code> along the corresponding dimension.</p><p>For value interpolation, <code>weights</code> will typically sum to 1. However, for gradient and Hessian computation this will not necessarily be true. For example, the gradient of one-dimensional linear interpolation can be represented as</p><pre><code class="language-none">gwi = WeightedIndex(i:i+1, (-1, 1))
g1 = a[gwi]</code></pre><p>For a three-dimensional array <code>A</code>, one might compute <code>∂A/∂x₂</code> (the second component of the gradient) as <code>A[wi1, gwi2, wi3]</code>, where <code>wi1</code> and <code>wi3</code> are &quot;value&quot; weights and <code>gwi2</code> &quot;gradient&quot; weights.</p><p><code>indexes</code> may be supplied as a range or as a tuple of the same length as <code>weights</code>. The latter is applicable, e.g., for periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/9afbfc9fdfec2749b4b3ee1338671ffb6989525e/src/Interpolations.jl#L183-L225">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../devdocs/">« Developer documentation</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 20 September 2020 23:26">Sunday 20 September 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
