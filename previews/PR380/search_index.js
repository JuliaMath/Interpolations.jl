var documenterSearchIndex = {"docs":
[{"location":"extrapolation/#Extrapolation-1","page":"Extrapolation","title":"Extrapolation","text":"","category":"section"},{"location":"extrapolation/#","page":"Extrapolation","title":"Extrapolation","text":"The call to extrapolate defines what happens if you try to index into the interpolation object with coordinates outside of its bounds in any dimension. The implemented boundary conditions are Throw, Flat, Line, Periodic and Reflect, or you can pass a constant to be used as a \"fill\" value returned for any out-of-bounds evaluation. Periodic and Reflect require that there is a method of Base.mod that can handle the indices used.","category":"page"},{"location":"extrapolation/#","page":"Extrapolation","title":"Extrapolation","text":"Examples:","category":"page"},{"location":"extrapolation/#","page":"Extrapolation","title":"Extrapolation","text":"itp = interpolate(1:7, BSpline(Linear()))\netpf = extrapolate(itp, Flat())   # gives 1 on the left edge and 7 on the right edge\netp0 = extrapolate(itp, 0)        # gives 0 everywhere outside [1,7]","category":"page"},{"location":"api/#Public-API-1","page":"Library","title":"Public API","text":"","category":"section"},{"location":"api/#","page":"Library","title":"Library","text":"DocTestSetup= quote\nusing Interpolations\nend","category":"page"},{"location":"api/#","page":"Library","title":"Library","text":"Modules = [Interpolations]\nPrivate = false\nOrder = [:function, :type]","category":"page"},{"location":"api/#Interpolations.CubicSplineInterpolation","page":"Library","title":"Interpolations.CubicSplineInterpolation","text":"etp = CubicSplineInterpolation(knots, A; bc=Line(OnGrid()), extrapolation_bc=Throw())\n\nA shorthand for extrapolate(interpolate(knots, A, BSpline(Cubic(bc))), extrapolation_bc).\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.LinearInterpolation","page":"Library","title":"Interpolations.LinearInterpolation","text":"etp = LinearInterpolation(knots, A; extrapolation_bc=Throw())\n\nA shorthand for extrapolate(interpolate(knots, A, scheme), extrapolation_bc), where scheme is either BSpline(Linear()) or Gridded(Linear()) depending on whether knots are ranges or vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.bounds-Tuple{AbstractInterpolation}","page":"Library","title":"Interpolations.bounds","text":"bounds(itp::AbstractInterpolation)\n\nReturn the bounds of the domain of itp as a tuple of (min, max) pairs for each coordinate. This is best explained by example:\n\njulia> itp = interpolate([1 2 3; 4 5 6], BSpline(Linear()));\n\njulia> bounds(itp)\n((1, 2), (1, 3))\n\njulia> data = 1:3;\n\njulia> knots = ([10, 11, 13.5],);\n\njulia> itp = interpolate(knots, data, Gridded(Linear()));\n\njulia> bounds(itp)\n((10.0, 13.5),)\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.extrapolate-Union{Tuple{ET}, Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},ET}} where ET<:Union{Tuple{Vararg{Union{Tuple{BoundaryCondition,BoundaryCondition}, BoundaryCondition},N} where N}, BoundaryCondition} where IT where N where T","page":"Library","title":"Interpolations.extrapolate","text":"extrapolate(itp, scheme) adds extrapolation behavior to an interpolation object, according to the provided scheme.\n\nThe scheme can take any of these values:\n\nThrow - throws a BoundsError for out-of-bounds indices\nFlat - for constant extrapolation, taking the closest in-bounds value\nLine - linear extrapolation (the wrapped interpolation object must support gradient)\nReflect - reflecting extrapolation (indices must support mod)\nPeriodic - periodic extrapolation (indices must support mod)\n\nYou can also combine schemes in tuples. For example, the scheme (Line(), Flat()) will use linear extrapolation in the first dimension, and constant in the second.\n\nFinally, you can specify different extrapolation behavior in different direction. ((Line(),Flat()), Flat()) will extrapolate linearly in the first dimension if the index is too small, but use constant etrapolation if it is too large, and always use constant extrapolation in the second dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.extrapolate-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},Any}} where IT where N where T","page":"Library","title":"Interpolations.extrapolate","text":"extrapolate(itp, fillvalue) creates an extrapolation object that returns the fillvalue any time the indexes in itp(x1,x2,...) are out-of-bounds.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray,IT}} where IT<:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline},N} where N}, BSpline}","page":"Library","title":"Interpolations.interpolate","text":"itp = interpolate(A, interpmode)\n\nInterpolate an array A in the mode determined by interpmode. interpmode may be one of\n\nNoInterp()\nBSpline(Constant())\nBSpline(Linear())\nBSpline(Quadratic(bc)) (see BoundaryCondition)\nBSpline(Cubic(bc))\n\nIt may also be a tuple of such values, if you want to use different interpolation schemes along each axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.interpolate-Union{Tuple{IT}, Tuple{N}, Tuple{Tel}, Tuple{Tuple{Vararg{Union{AbstractArray{T,1}, Tuple} where T,N}},AbstractArray{Tel,N},IT}} where IT<:Union{NoInterp, Tuple{Vararg{Union{NoInterp, Gridded},N} where N}, Gridded} where N where Tel","page":"Library","title":"Interpolations.interpolate","text":"itp = interpolate((nodes1, nodes2, ...), A, interpmode)\n\nInterpolate an array A on a non-uniform but rectangular grid specified by the given nodes, in the mode determined by interpmode.\n\ninterpmode may be one of\n\nNoInterp()\nGridded(Constant())\nGridded(Linear())\n\nIt may also be a tuple of such values, if you want to use different interpolation schemes along each axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.scale-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},Vararg{AbstractRange,N}}} where IT where N where T","page":"Library","title":"Interpolations.scale","text":"scale(itp, xs, ys, ...) scales an existing interpolation object to allow for indexing using other coordinate axes than unit ranges, by wrapping the interpolation object and transforming the indices from the provided axes onto unit ranges upon indexing.\n\nThe parameters xs etc must be either ranges or linspaces, and there must be one coordinate range/linspace for each dimension of the interpolation object.\n\nFor every NoInterp dimension of the interpolation object, the range must be exactly 1:size(itp, d).\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.BSpline","page":"Library","title":"Interpolations.BSpline","text":"BSpline(degree)\n\nA flag signaling BSpline (integer-grid b-spline) interpolation along the corresponding axis. degree is one of Constant, Linear, Quadratic, or Cubic.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.CardinalMonotonicInterpolation","page":"Library","title":"Interpolations.CardinalMonotonicInterpolation","text":"CardinalMonotonicInterpolation(tension)\n\nCubic cardinal splines, uses tension parameter which must be between [0,1] Cubin cardinal splines can overshoot for non-monotonic data (increasing tension reduces overshoot).\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Constant","page":"Library","title":"Interpolations.Constant","text":"Constant b-splines are nearest-neighbor interpolations, and effectively return A[round(Int,x)] when interpolating.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Cubic","page":"Library","title":"Interpolations.Cubic","text":"Cubic(bc::BoundaryCondition)\n\nIndicate that the corresponding axis should use cubic interpolation.\n\nExtended help\n\nAssuming uniform knots with spacing 1, the ith piece of cubic spline implemented here is defined as follows.\n\ny_i(x) = cm p(x-i) + c q(x-i) + cp q(1- (x-i)) + cpp p(1 - (x-i))\n\nwhere\n\np(δx) = 1/6 * (1-δx)^3\nq(δx) = 2/3 - δx^2 + 1/2 δx^3\n\nand the values cX for X ∈ {m, _, p, pp} are the pre-filtered coefficients.\n\nFor future reference, this expands out to the following polynomial:\n\ny_i(x) = 1/6 cm (1+i-x)^3 + c (2/3 - (x-i)^2 + 1/2 (x-i)^3) +\n         cp (2/3 - (1+i-x)^2 + 1/2 (1+i-x)^3) + 1/6 cpp (x-i)^3\n\nWhen we derive boundary conditions we will use derivatives y_0'(x) and y_0''(x)\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.FiniteDifferenceMonotonicInterpolation","page":"Library","title":"Interpolations.FiniteDifferenceMonotonicInterpolation","text":"FiniteDifferenceMonotonicInterpolation\n\nClassic cubic interpolation, no tension parameter. Finite difference can overshoot for non-monotonic data.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Flat","page":"Library","title":"Interpolations.Flat","text":"Flat(gt) sets the extrapolation slope to zero\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.FritschButlandMonotonicInterpolation","page":"Library","title":"Interpolations.FritschButlandMonotonicInterpolation","text":"FritschButlandMonotonicInterpolation\n\nMonotonic interpolation based on  Fritsch & Butland (1984), \"A Method for Constructing Local Monotone Piecewise Cubic Interpolants\", doi:10.1137/0905021.\n\nFaster than FritschCarlsonMonotonicInterpolation (only requires one pass) but somewhat higher apparent \"tension\".\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.FritschCarlsonMonotonicInterpolation","page":"Library","title":"Interpolations.FritschCarlsonMonotonicInterpolation","text":"FritschCarlsonMonotonicInterpolation\n\nMonotonic interpolation based on Fritsch & Carlson (1980), \"Monotone Piecewise Cubic Interpolation\", doi:10.1137/0717021.\n\nTangents are first initialized, then adjusted if they are not monotonic can overshoot for non-monotonic data\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.InPlace","page":"Library","title":"Interpolations.InPlace","text":"InPlace(gt) is a boundary condition that allows prefiltering to occur in-place (it typically requires padding)\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.InPlaceQ","page":"Library","title":"Interpolations.InPlaceQ","text":"InPlaceQ(gt) is similar to InPlace(gt), but is exact when the values being interpolated arise from an underlying quadratic. It is primarily useful for testing purposes, allowing near-exact (to machine precision) comparisons against ground truth.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Lanczos","page":"Library","title":"Interpolations.Lanczos","text":"Lanczos{N}(a=4)\n\nLanczos resampling via a kernel with scale parameter a and support over N neighbors.\n\nThis form of interpolation is merely the discrete convolution of the samples with a Lanczos kernel of size a. The size is directly related to how \"far\" the interpolation will reach for information, and has O(N^2) impact on runtime. An alternative implementation matching lanczos4 from OpenCV is available as Lanczos4OpenCV.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Lanczos4OpenCV","page":"Library","title":"Interpolations.Lanczos4OpenCV","text":"Lanczos4OpenCV()\n\nAlternative implementation of Lanczos resampling using algorithm lanczos4 function of OpenCV: https://github.com/opencv/opencv/blob/de15636724967faf62c2d1bce26f4335e4b359e5/modules/imgproc/src/resize.cpp#L917-L946\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Line","page":"Library","title":"Interpolations.Line","text":"Line(gt) uses a constant slope for extrapolation\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Linear","page":"Library","title":"Interpolations.Linear","text":"Linear()\n\nIndicate that the corresponding axis should use linear interpolation.\n\nExtended help\n\nAssuming uniform knots with spacing 1, the ith piece of linear b-spline implemented here is defined as follows.\n\ny_i(x) = c p(x) + cp p(1-x)\n\nwhere\n\np(δx) = x\n\nand the values cX for X ∈ {_, p} are the coefficients.\n\nLinear b-splines are naturally interpolating, and require no prefiltering; there is therefore no need for boundary conditions to be provided.\n\nAlso, although the implementation is slightly different in order to re-use the framework built for general b-splines, the resulting interpolant is just a piecewise linear function connecting each pair of neighboring data points.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.LinearMonotonicInterpolation","page":"Library","title":"Interpolations.LinearMonotonicInterpolation","text":"LinearMonotonicInterpolation\n\nSimple linear interpolation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.NoInterp","page":"Library","title":"Interpolations.NoInterp","text":"NoInterp() indicates that the corresponding axis must use integer indexing (no interpolation is to be performed)\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.OnCell","page":"Library","title":"Interpolations.OnCell","text":"OnCell() indicates that the boundary condition applies a half-gridspacing beyond the first & last nodes\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.OnGrid","page":"Library","title":"Interpolations.OnGrid","text":"OnGrid() indicates that the boundary condition applies at the first & last nodes\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Periodic","page":"Library","title":"Interpolations.Periodic","text":"Periodic(gt) applies periodic boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Quadratic","page":"Library","title":"Interpolations.Quadratic","text":"Quadratic(bc::BoundaryCondition)\n\nIndicate that the corresponding axis should use quadratic interpolation.\n\nExtended help\n\nAssuming uniform knots with spacing 1, the ith piece of quadratic spline implemented here is defined as follows:\n\ny_i(x) = cm p(x-i) + c q(x) + cp p(1-(x-i))\n\nwhere\n\np(δx) = (δx - 1)^2 / 2\nq(δx) = 3/4 - δx^2\n\nand the values for cX for X ∈ {m,_,p} are the pre-filtered coefficients.\n\nFor future reference, this expands to the following polynomial:\n\ny_i(x) = cm * 1/2 * (x-i-1)^2 + c * (3/4 - x + i)^2 + cp * 1/2 * (x-i)^2\n\nWhen we derive boundary conditions we will use derivatives y_1'(x-1) and y_1''(x-1)\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Reflect","page":"Library","title":"Interpolations.Reflect","text":"Reflect(gt) applies reflective boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.SteffenMonotonicInterpolation","page":"Library","title":"Interpolations.SteffenMonotonicInterpolation","text":"SteffenMonotonicInterpolation\n\nMonotonic interpolation based on Steffen (1990), \"A Simple Method for Monotonic Interpolation in One Dimension\", http://adsabs.harvard.edu/abs/1990A%26A...239..443S\n\nOnly one pass, results usually between FritschCarlson and FritschButland.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.Throw","page":"Library","title":"Interpolations.Throw","text":"Throw(gt) causes beyond-the-edge extrapolation to throw an error\n\n\n\n\n\n","category":"type"},{"location":"api/#Internal-API-1","page":"Library","title":"Internal API","text":"","category":"section"},{"location":"api/#","page":"Library","title":"Library","text":"Modules = [Interpolations]\nPublic = false\nOrder = [:function, :type]","category":"page"},{"location":"api/#Interpolations.boundstep","page":"Library","title":"Interpolations.boundstep","text":"Returns half the width of one step of the range.\n\nThis function is used to calculate the upper and lower bounds of OnCell interpolation objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.count_interp_dims-Union{Tuple{Type{ITP}}, Tuple{ITP}} where ITP<:AbstractInterpolation","page":"Library","title":"Interpolations.count_interp_dims","text":"n = count_interp_dims(ITP)\n\nCount the number of dimensions along which type ITP is interpolating. NoInterp dimensions do not contribute to the sum.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.gradient_weights","page":"Library","title":"Interpolations.gradient_weights","text":"w = gradient_weights(degree, δx)\n\nCompute the weights for interpolation of the gradient at an offset δx from the \"base\" position. degree describes the interpolation scheme.\n\nExample\n\njulia> Interpolations.gradient_weights(Linear(), 0.2)\n(-1.0, 1.0)\n\nThis defines the gradient of a linear interpolation at 3.2 as y[4] - y[3].\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.hessian_weights","page":"Library","title":"Interpolations.hessian_weights","text":"w = hessian_weights(degree, δx)\n\nCompute the weights for interpolation of the hessian at an offset δx from the \"base\" position. degree describes the interpolation scheme.\n\nExample\n\njulia> Interpolations.hessian_weights(Linear(), 0.2)\n(0.0, 0.0)\n\nLinear interpolation uses straight line segments, so the second derivative is zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.inner_system_diags","page":"Library","title":"Interpolations.inner_system_diags","text":"dl, d, du = inner_system_diags{T,IT}(::Type{T}, n::Int, ::Type{IT})\n\nHelper function to generate the prefiltering equation system: generates the diagonals for a n-by-n tridiagonal matrix with eltype T corresponding to the interpolation type IT.\n\ndl, d, and du are intended to be used e.g. as in M = Tridiagonal(dl, d, du)\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.inner_system_diags-Union{Tuple{T}, Tuple{Type{T},Int64,Cubic}} where T","page":"Library","title":"Interpolations.inner_system_diags","text":"Cubic: continuity in function value, first and second derivatives yields\n\n2/3 1/6\n1/6 2/3 1/6\n    1/6 2/3 1/6\n       ⋱  ⋱   ⋱\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.lanczos-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Any}} where T","page":"Library","title":"Interpolations.lanczos","text":"lanczos(x, a, n=a)\n\nImplementation of the Lanczos kernel\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system","page":"Library","title":"Interpolations.prefiltering_system","text":"M, b = prefiltering_system{T,TC,GT<:GridType,D<:Degree}m(::T, ::Type{TC}, n::Int, ::Type{D}, ::Type{GT})\n\nGiven element types (T, TC) and interpolation scheme (GT, D) as well the number of rows in the data input (n), compute the system used to prefilter spline coefficients. Boundary conditions determine the values on the first and last rows.\n\nSome of these boundary conditions require that these rows have off-tridiagonal elements (e.g the [1,3] element of the matrix). To maintain the efficiency of solving tridiagonal systems, the Woodbury matrix identity is used to add additional elements off the main 3 diagonals.\n\nThe filtered coefficients are given by solving the equation system\n\nM * c = v + b\n\nwhere c are the sought coefficients, and v are the data points.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{BC}}} where BC<:Union{Flat{OnCell}, Reflect{OnCell}} where TC where T","page":"Library","title":"Interpolations.prefiltering_system","text":"Quadratic{Flat} OnCell and Quadratic{Reflect} OnCell amounts to setting y_1'(x) = 0 at x=1/2. Applying this condition yields\n\n-cm + c = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{BC}}} where BC<:Union{Flat{OnGrid}, Reflect{OnGrid}} where TC where T","page":"Library","title":"Interpolations.prefiltering_system","text":"Quadratic{Flat} OnGrid and Quadratic{Reflect} OnGrid amount to setting y_1'(x) = 0 at x=1. Applying this condition yields\n\n-cm + cp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{#s12} where #s12<:Free}} where TC where T","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Free} OnGrid and Cubic{Free} OnCell amount to requiring an extra continuous derivative at the second-to-last cell boundary; this means y_1'''(2) = y_2'''(2), yielding\n\n1 cm -3 c + 3 cp -1 cpp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{#s12} where #s12<:Periodic}} where TC where T","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Periodic} OnGrid closes the system by looking at the coefficients themselves as periodic, yielding\n\nc0 = c(N+1)\n\nwhere N is the number of data points.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Flat{OnCell}}}} where TC where T","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Flat}, OnCell amounts to setting y_1'(x) = 0 at x = 1/2. Applying this condition yields\n\n-9/8 cm + 11/8 c - 3/8 cp + 1/8 cpp = 0\n\nor, equivalently,\n\n-9 cm + 11 c -3 cp + 1 cpp = 0\n\n(Note that we use y_1'(x) although it is strictly not valid in this domain; if we were to use y_0'(x) we would have to introduce new coefficients, so that would not close the system. Instead, we extend the outermost polynomial for an extra half-cell.)\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Flat{OnGrid}}}} where TC where T","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Flat} OnGrid amounts to setting y_1'(x) = 0 at x = 1. Applying this condition yields\n\n-cm + cp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Line{OnCell}}}} where TC where T","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Line} OnCell amounts to setting y_1''(x) = 0 at x = 1/2. Applying this condition yields\n\n3 cm -7 c + 5 cp -1 cpp = 0\n\n(Note that we use y_1'(x) although it is strictly not valid in this domain; if we were to use y_0'(x) we would have to introduce new coefficients, so that would not close the system. Instead, we extend the outermost polynomial for an extra half-cell.)\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Line{OnGrid}}}} where TC where T","page":"Library","title":"Interpolations.prefiltering_system","text":"Cubic{Line} OnGrid amounts to setting y_1''(x) = 0 at x = 1. Applying this condition gives:\n\n1 cm -2 c + 1 cp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12<:Free}} where TC where T","page":"Library","title":"Interpolations.prefiltering_system","text":"Quadratic{Free} OnGrid and Quadratic{Free} OnCell amount to requiring an extra continuous derivative at the second-to-last cell boundary; this means that y_1''(3/2) = y_2''(3/2), yielding\n\n1 cm -3 c + 3 cp - cpp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12<:Line}} where TC where T","page":"Library","title":"Interpolations.prefiltering_system","text":"Quadratic{Line} OnGrid and Quadratic{Line} OnCell amount to setting y_1''(x) = 0 at x=1 and x=1/2 respectively. Since y_i''(x) is independent of x for a quadratic b-spline, these both yield\n\n1 cm -2 c + 1 cp = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12<:Periodic}} where TC where T","page":"Library","title":"Interpolations.prefiltering_system","text":"Quadratic{Periodic} OnGrid and Quadratic{Periodic} OnCell close the system by looking at the coefficients themselves as periodic, yielding\n\nc0 = c(N+1)\n\nwhere N is the number of data points.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.rescale_gradient","page":"Library","title":"Interpolations.rescale_gradient","text":"rescale_gradient(r::AbstractRange)\n\nImplements the chain rule dy/dx = dy/du * du/dx for use when calculating gradients with scaled interpolation objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.show_ranged-Tuple{IO,Any,Any}","page":"Library","title":"Interpolations.show_ranged","text":"show_ranged(io, X, knots)\n\nA replacement for the default array-show for types that may not have the canonical evaluation points. rngs is the tuple of knots along each axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.value_weights","page":"Library","title":"Interpolations.value_weights","text":"w = value_weights(degree, δx)\n\nCompute the weights for interpolation of the value at an offset δx from the \"base\" position. degree describes the interpolation scheme.\n\nExample\n\njulia> Interpolations.value_weights(Linear(), 0.2)\n(0.8, 0.2)\n\nThis corresponds to the fact that linear interpolation at x + 0.2 is 0.8*y[x] + 0.2*y[x+1].\n\n\n\n\n\n","category":"function"},{"location":"api/#Interpolations.weightedindexes-Union{Tuple{N}, Tuple{F}, Tuple{F,Tuple{Vararg{Flag,N}},Tuple{Vararg{AbstractArray{T,1} where T,N}},Tuple{Vararg{Number,N}}}} where N where F","page":"Library","title":"Interpolations.weightedindexes","text":"weightedindexes(fs, itpflags, nodes, xs)\n\nCompute WeightedIndex values for evaluation at the position xs.... fs is a function or tuple of functions indicating the types of index required, typically value_weights, gradient_weights, and/or hessian_weights. itpflags and nodes can be obtained from itpinfo(itp)....\n\nSee the \"developer documentation\" for further information.\n\n\n\n\n\n","category":"method"},{"location":"api/#Interpolations.BSplineInterpolation","page":"Library","title":"Interpolations.BSplineInterpolation","text":"BSplineInterpolation{T,N,TCoefs,IT,Axs}\n\nAn interpolant-type for b-spline interpolation on a uniform grid with integer nodes. T indicates the element type for operations like collect(itp), and may also agree with the values obtained from itp(x, y, ...) at least for certain types of x and y. N is the dimensionality of the interpolant. The remaining type-parameters describe the types of fields:\n\nthe coefs field holds the interpolation coefficients. Depending on prefiltering, these may or may not be the same as the supplied array of interpolant values.\nparentaxes holds the axes of the parent. Depending on prefiltering this may be \"narrower\" than the axes of coefs.\nit holds the interpolation type, e.g., BSpline(Linear()) or (BSpline(Quadratic(OnCell()),BSpline(Linear())).\n\nBSplineInterpolation objects are typically created with interpolate. However, for customized control you may also construct them with\n\nBSplineInterpolation(TWeights, coefs, it, axs)\n\nwhere T gets computed from the product of TWeights and eltype(coefs). (This is equivalent to indicating that you'll be evaluating at locations itp(x::TWeights, y::TWeights, ...).)\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.BoundaryCondition","page":"Library","title":"Interpolations.BoundaryCondition","text":"BoundaryCondition\n\nAn abstract type with one of the following values (see the help for each for details):\n\nThrow(gt)\nFlat(gt)\nLine(gt)\nFree(gt)\nPeriodic(gt)\nReflect(gt)\nInPlace(gt)\nInPlaceQ(gt)\n\nwhere gt is the grid type, e.g., OnGrid() or OnCell().\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.BoundsCheckStyle","page":"Library","title":"Interpolations.BoundsCheckStyle","text":"BoundsCheckStyle(itp)\n\nA trait to determine dispatch of bounds-checking for itp. Can return NeedsCheck(), in which case bounds-checking is performed, or CheckWillPass() in which case the check will return true.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.LanczosInterpolation","page":"Library","title":"Interpolations.LanczosInterpolation","text":"LanczosInterpolation\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.MonotonicInterpolation","page":"Library","title":"Interpolations.MonotonicInterpolation","text":"MonotonicInterpolation\n\nMonotonic interpolation up to third order represented by type, knots and coefficients.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.MonotonicInterpolationType","page":"Library","title":"Interpolations.MonotonicInterpolationType","text":"MonotonicInterpolationType\n\nAbstract class for all types of monotonic interpolation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Interpolations.WeightedIndex","page":"Library","title":"Interpolations.WeightedIndex","text":"wi = WeightedIndex(indexes, weights)\n\nConstruct a weighted index wi, which can be thought of as a generalization of an ordinary array index to the context of interpolation. For an ordinary vector a, a[i] extracts the element at index i. When interpolating, one is typically interested in a range of indexes and the output is some weighted combination of array values at these indexes. For example, for linear interpolation at a location x between integers i and i+1, we have\n\nret = (1-f)*a[i] + f*a[i+1]\n\nwhere f = x-i lies between 0 and 1. This can be represented as a[wi], where\n\nwi = WeightedIndex(i:i+1, (1-f, f))\n\ni.e.,\n\nret = sum(a[indexes] .* weights)\n\nLinear interpolation thus constructs weighted indices using a 2-tuple for weights and a length-2 indexes range. Higher-order interpolation would involve more positions and weights (e.g., 3-tuples for quadratic interpolation, 4-tuples for cubic).\n\nIn multiple dimensions, separable interpolation schemes are implemented in terms of multiple weighted indices, accessing A[wi1, wi2, ...] where each wi is the WeightedIndex along the corresponding dimension.\n\nFor value interpolation, weights will typically sum to 1. However, for gradient and Hessian computation this will not necessarily be true. For example, the gradient of one-dimensional linear interpolation can be represented as\n\ngwi = WeightedIndex(i:i+1, (-1, 1))\ng1 = a[gwi]\n\nFor a three-dimensional array A, one might compute ∂A/∂x₂ (the second component of the gradient) as A[wi1, gwi2, wi3], where wi1 and wi3 are \"value\" weights and gwi2 \"gradient\" weights.\n\nindexes may be supplied as a range or as a tuple of the same length as weights. The latter is applicable, e.g., for periodic boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"interpolations/#General-usage-1","page":"General usage","title":"General usage","text":"","category":"section"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"Note: the current version of Interpolations supports interpolation evaluation using index calls [], but this feature will be deprecated in future. We highly recommend function calls with () as follows.","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"Given an AbstractArray A, construct an \"interpolation object\" itp as","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"itp = interpolate(A, options...)","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"where options... (discussed below) controls the type of interpolation you want to perform.  This syntax assumes that the samples in A are equally-spaced.","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"To evaluate the interpolation at position (x, y, ...), simply do","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"v = itp(x, y, ...)","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"Some interpolation objects support computation of the gradient, which can be obtained as","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"g = Interpolations.gradient(itp, x, y, ...)","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"or as","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"Interpolations.gradient!(g, itp, x, y, ...)","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"where g is a pre-allocated vector.","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"Some interpolation objects support computation of the hessian, which can be obtained as","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"h = Interpolations.hessian(itp, x, y, ...)","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"or","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"Interpolations.hessian!(h, itp, x, y, ...)","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"where h is a pre-allocated matrix.","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"A may have any element type that supports the operations of addition and multiplication.  Examples include scalars like Float64, Int, and Rational, but also multi-valued types like RGB color vectors.","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"Positions (x, y, ...) are n-tuples of numbers. Typically these will be real-valued (not necessarily integer-valued), but can also be of types such as DualNumbers if you want to verify the computed value of gradients. (Alternatively, verify gradients using ForwardDiff.) You can also use Julia's iterator objects, e.g.,","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"function ongrid!(dest, itp)\n    for I in CartesianIndices(itp)\n        dest[I] = itp(I)\n    end\nend","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"would store the on-grid value at each grid point of itp in the output dest. Finally, courtesy of Julia's indexing rules, you can also use","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"fine = itp(range(1,stop=10,length=1001), range(1,stop=15,length=201))","category":"page"},{"location":"interpolations/#","page":"General usage","title":"General usage","text":"There is also an abbreviated Convenience notation.","category":"page"},{"location":"convenience-construction/#Convenience-notation-1","page":"Convenience Constructors","title":"Convenience notation","text":"","category":"section"},{"location":"convenience-construction/#","page":"Convenience Constructors","title":"Convenience Constructors","text":"For linear and cubic spline interpolations, LinearInterpolation and CubicSplineInterpolation can be used to create interpolating and extrapolating objects handily:","category":"page"},{"location":"convenience-construction/#","page":"Convenience Constructors","title":"Convenience Constructors","text":"f(x) = log(x)\nxs = 1:0.2:5\nA = [f(x) for x in xs]\n\n# linear interpolation\ninterp_linear = LinearInterpolation(xs, A)\ninterp_linear(3) # exactly log(3)\ninterp_linear(3.1) # approximately log(3.1)\n\n# cubic spline interpolation\ninterp_cubic = CubicSplineInterpolation(xs, A)\ninterp_cubic(3) # exactly log(3)\ninterp_cubic(3.1) # approximately log(3.1)","category":"page"},{"location":"convenience-construction/#","page":"Convenience Constructors","title":"Convenience Constructors","text":"which support multidimensional data as well:","category":"page"},{"location":"convenience-construction/#","page":"Convenience Constructors","title":"Convenience Constructors","text":"f(x,y) = log(x+y)\nxs = 1:0.2:5\nys = 2:0.1:5\nA = [f(x,y) for x in xs, y in ys]\n\n# linear interpolation\ninterp_linear = LinearInterpolation((xs, ys), A)\ninterp_linear(3, 2) # exactly log(3 + 2)\ninterp_linear(3.1, 2.1) # approximately log(3.1 + 2.1)\n\n# cubic spline interpolation\ninterp_cubic = CubicSplineInterpolation((xs, ys), A)\ninterp_cubic(3, 2) # exactly log(3 + 2)\ninterp_cubic(3.1, 2.1) # approximately log(3.1 + 2.1)","category":"page"},{"location":"convenience-construction/#","page":"Convenience Constructors","title":"Convenience Constructors","text":"For extrapolation, i.e., when interpolation objects are evaluated in coordinates outside the range provided in constructors, the default option for a boundary condition is Throw so that they will return an error. Interested users can specify boundary conditions by providing an extra parameter for extrapolation_bc:","category":"page"},{"location":"convenience-construction/#","page":"Convenience Constructors","title":"Convenience Constructors","text":"f(x) = log(x)\nxs = 1:0.2:5\nA = [f(x) for x in xs]\n\n# extrapolation with linear boundary conditions\nextrap = LinearInterpolation(xs, A, extrapolation_bc = Line())\n\n@test extrap(1 - 0.2) # ≈ f(1) - (f(1.2) - f(1))\n@test extrap(5 + 0.2) # ≈ f(5) + (f(5) - f(4.8))","category":"page"},{"location":"convenience-construction/#","page":"Convenience Constructors","title":"Convenience Constructors","text":"You can also use a \"fill\" value, which gets returned whenever you ask for out-of-range values:","category":"page"},{"location":"convenience-construction/#","page":"Convenience Constructors","title":"Convenience Constructors","text":"extrap = LinearInterpolation(xs, A, extrapolation_bc = NaN)\n@test isnan(extrap(5.2))","category":"page"},{"location":"convenience-construction/#","page":"Convenience Constructors","title":"Convenience Constructors","text":"Irregular grids are supported as well; note that presently only LinearInterpolation supports irregular grids.","category":"page"},{"location":"convenience-construction/#","page":"Convenience Constructors","title":"Convenience Constructors","text":"xs = [x^2 for x = 1:0.2:5]\nA = [f(x) for x in xs]\n\n# linear interpolation\ninterp_linear = LinearInterpolation(xs, A)\ninterp_linear(1) # exactly log(1)\ninterp_linear(1.05) # approximately log(1.05)","category":"page"},{"location":"#Interpolations-1","page":"Home","title":"Interpolations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Build Status) (Image: PkgEval Status) (Image: Interpolations)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"NEWS v0.9 was a breaking release. See the news for details on how to update.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package implements a variety of interpolation schemes for the Julia language.  It has the goals of ease-of-use, broad algorithmic support, and exceptional performance.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Currently this package's support is best for B-splines and also supports irregular grids.  However, the API has been designed with intent to support more options. Pull-requests are more than welcome! It should be noted that the API may continue to evolve over time.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Other interpolation packages for Julia include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Dierckx.jl\nGridInterpolations.jl\nApproXD.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Some of these packages support methods that Interpolations does not, so if you can't find what you need here, check one of them or submit a pull request here.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Just","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Interpolations\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"from the Julia REPL.","category":"page"},{"location":"control/#Control-of-interpolation-algorithm-1","page":"Interpolation algorithms","title":"Control of interpolation algorithm","text":"","category":"section"},{"location":"control/#BSplines-1","page":"Interpolation algorithms","title":"BSplines","text":"","category":"section"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"The interpolation type is described in terms of degree and, if necessary, boundary conditions. There are currently four degrees available: Constant, Linear, Quadratic,  and Cubic corresponding to B-splines of degree 0, 1, 2, and 3 respectively.","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"B-splines of quadratic or higher degree require solving an equation system to obtain the interpolation coefficients, and for that you must specify a boundary condition that is applied to close the system. The following boundary conditions are implemented: Flat, Line (alternatively, Natural), Free, Periodic and Reflect; their mathematical implications are described in detail in the pdf document under /doc/latex. When specifying these boundary conditions you also have to specify whether they apply at the edge grid point (OnGrid()) or beyond the edge point halfway to the next (fictitious) grid point (OnCell()).","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Some examples:","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"# Nearest-neighbor interpolation\nitp = interpolate(a, BSpline(Constant()))\nv = itp(5.4)   # returns a[5]\n\n# (Multi)linear interpolation\nitp = interpolate(A, BSpline(Linear()))\nv = itp(3.2, 4.1)  # returns 0.9*(0.8*A[3,4]+0.2*A[4,4]) + 0.1*(0.8*A[3,5]+0.2*A[4,5])\n\n# Quadratic interpolation with reflecting boundary conditions\n# Quadratic is the lowest order that has continuous gradient\nitp = interpolate(A, BSpline(Quadratic(Reflect(OnCell()))))\n\n# Linear interpolation in the first dimension, and no interpolation (just lookup) in the second\nitp = interpolate(A, (BSpline(Linear()), NoInterp()))\nv = itp(3.65, 5)  # returns  0.35*A[3,5] + 0.65*A[4,5]","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"There are more options available, for example:","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"# In-place interpolation\nitp = interpolate!(A, BSpline(Quadratic(InPlace(OnCell()))))","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"which destroys the input A but also does not need to allocate as much memory.","category":"page"},{"location":"control/#Scaled-BSplines-1","page":"Interpolation algorithms","title":"Scaled BSplines","text":"","category":"section"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"BSplines assume your data is uniformly spaced on the grid 1:N, or its multidimensional equivalent. If you have data of the form [f(x) for x in A], you need to tell Interpolations about the grid A. If A is not uniformly spaced, you must use gridded interpolation described below. However, if A is a collection of ranges or linspaces, you can use scaled BSplines. This is more efficient because the gridded algorithm does not exploit the uniform spacing. Scaled BSplines can also be used with any spline degree available for BSplines, while gridded interpolation does not currently support quadratic or cubic splines.","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Some examples,","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"A_x = 1.:2.:40.\nA = [log(x) for x in A_x]\nitp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))\nsitp = scale(itp, A_x)\nsitp(3.) # exactly log(3.)\nsitp(3.5) # approximately log(3.5)","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"For multidimensional uniformly spaced grids","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"A_x1 = 1:.1:10\nA_x2 = 1:.5:20\nf(x1, x2) = log(x1+x2)\nA = [f(x1,x2) for x1 in A_x1, x2 in A_x2]\nitp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))\nsitp = scale(itp, A_x1, A_x2)\nsitp(5., 10.) # exactly log(5 + 10)\nsitp(5.6, 7.1) # approximately log(5.6 + 7.1)","category":"page"},{"location":"control/#Gridded-interpolation-1","page":"Interpolation algorithms","title":"Gridded interpolation","text":"","category":"section"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"These use a very similar syntax to BSplines, with the major exception being that one does not get to choose the grid representation (they are all OnGrid). As such one must specify a set of coordinate arrays defining the nodes of the array.","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"In 1D","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"A = rand(20)\nA_x = 1.0:2.0:40.0\nnodes = (A_x,)\nitp = interpolate(nodes, A, Gridded(Linear()))\nitp(2.0)","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"The spacing between adjacent samples need not be constant; indeed, if they are constant, you'll get better performance with scaled.","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"The general syntax is","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"itp = interpolate(nodes, A, options...)","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"where nodes = (xnodes, ynodes, ...) specifies the positions along each axis at which the array A is sampled for arbitrary (\"rectangular\") samplings.","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"For example:","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"A = rand(8,20)\nnodes = ([x^2 for x = 1:8], [0.2y for y = 1:20])\nitp = interpolate(nodes, A, Gridded(Linear()))\nitp(4,1.2)  # approximately A[2,6]","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"One may also mix modes, by specifying a mode vector in the form of an explicit tuple:","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"itp = interpolate(nodes, A, (Gridded(Linear()),Gridded(Constant())))","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Presently there are only three modes for gridded:","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Gridded(Linear())","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"whereby a linear interpolation is applied between nodes,","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Gridded(Constant())","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"whereby nearest neighbor interpolation is used on the applied axis,","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"NoInterp()","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"whereby the coordinate of the selected input vector MUST be located on a grid point. Requests for off grid coordinates results in the throwing of an error.","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"missing data will naturally propagate through the interpolation, where some values will become missing. To avoid that, one can filter out the missing data points and use a gridded interpolation. For example:","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"x = 1:6\nA = [i == 3 ? missing : i for i in x]\nxf = [xi for (xi,a) in zip(x, A) if !ismissing(a)]\nAf = [a for a in A if !ismissing(a)]\nitp = interpolate((xf, ), Af, Gridded(Linear()))","category":"page"},{"location":"control/#Parametric-splines-1","page":"Interpolation algorithms","title":"Parametric splines","text":"","category":"section"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"Given a set a knots with coordinates x(t) and y(t), a parametric spline S(t) = (x(t),y(t)) parametrized by t in [0,1] can be constructed with the following code adapted from a post by Tomas Lycken:","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"using Interpolations\n\nt = 0:.1:1\nx = sin.(2π*t)\ny = cos.(2π*t)\nA = hcat(x,y)\n\nitp = Interpolations.scale(interpolate(A, (BSpline(Cubic(Natural(OnGrid()))), NoInterp())), t, 1:2)\n\ntfine = 0:.01:1\nxs, ys = [itp(t,1) for t in tfine], [itp(t,2) for t in tfine]","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"We can then plot the spline with:","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"using Plots\n\nscatter(x, y, label=\"knots\")\nplot!(xs, ys, label=\"spline\")","category":"page"},{"location":"control/#","page":"Interpolation algorithms","title":"Interpolation algorithms","text":"(Image: parametric spline)","category":"page"},{"location":"devdocs/#Developer-documentation-1","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"Conceptually, Interpolations.jl supports two operations: construction and usage of interpolants.","category":"page"},{"location":"devdocs/#Interpolant-construction-1","page":"Developer documentation","title":"Interpolant construction","text":"","category":"section"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"Construction creates the interpolant object. In some situations this is relatively trivial: for example, when using only NoInterp, Constant, or Linear interpolation schemes, construction essentially corresponds to recording the array of values and the \"settings\" (the interpolation scheme) specified at the time of construction. This case is simple because interpolated values may be efficiently computed directly from the on-grid values supplied at construction time: (1-Delta x) a_i  + Delta x a_i+1 reconstructs a_i when Delta x = 0.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"For Quadratic and higher orders, efficient computation requires that the array of values be prefiltered. This essentially corresponds to \"inverting\" the computation that will be performed during interpolation, so as to approximately reconstruct the original values at on-grid points. Generally speaking this corresponds to solving a nearly-tridiagonal system of equations, inverting an underlying interpolation scheme such as p(Delta x) tilde a_i-1 + q(Delta x) tilde a_i + p(1-Delta x) tilde a_i+1 for some functions p and q (see Quadratic for further details). Here tilde a is the pre-filtered version of a, designed so that substituting Delta x = 0 (for which one may not get 0 and 1 for the p and q calls, respectively) approximately recapitulates a_i.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"The exact system of equations to be solved depends on the interpolation order and boundary conditions. Boundary conditions often introduce deviations from perfect tridiagonality; these \"extras\" are handled efficiently by the WoodburyMatrices package. These computations are implemented independently along each axis using the AxisAlgorithms package.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"In the doc directory there are some old files that give some of the mathematical details. A useful reference is:","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"Thévenaz, Philippe, Thierry Blu, and Michael Unser. \"Interpolation revisited.\" IEEE Transactions on Medical Imaging 19.7 (2000): 739-758.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"note: Note\nAs an application of these concepts, note that supporting quadratic or cubic interpolation for Gridded would only require that someone implement prefiltering schemes for non-uniform grids; it's just a question of working out a little bit of math.","category":"page"},{"location":"devdocs/#Interpolant-usage-1","page":"Developer documentation","title":"Interpolant usage","text":"","category":"section"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"Usage occurs when evaluating itp(x, y...), or Interpolations.gradient(itp, x, y...), etc. Usage itself involves two sub-steps: computation of the weights and then performing the interpolation.","category":"page"},{"location":"devdocs/#Weight-computation-1","page":"Developer documentation","title":"Weight computation","text":"","category":"section"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"Weights depend on the interpolation scheme and the location x, y... but not the coefficients of the array we are interpolating. Consequently there are many circumstances where one might want to reuse previously-computed weights, and Interpolations.jl has been carefully designed with that kind of reuse in mind.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"The key concept here is the Interpolations.WeightedIndex, and there is no point repeating its detailed docstring here. It suffices to add that WeightedIndex is actually an abstract type, with two concrete subtypes:","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"WeightedAdjIndex is for indexes that will address adjacent points of the coefficient array (ones where the index increments by 1 along the corresponding dimension). These are used when prefiltering produces padding that can be used even at the edges, or for schemes like Linear interpolation which require no padding.\nWeightedArbIndex stores both the weight and index associated with each accessed grid point, and can therefore encode grid access patterns. These are used in specific circumstances–a prime example being periodic boundary conditions–where the coefficients array may be accessed at something other than adjacent locations.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"WeightedIndex computation reflects the interpolation scheme (e.g., Linear or Quadratic) and also whether one is computing values, gradients, or hessians. The handling of derivatives will be described further below.","category":"page"},{"location":"devdocs/#Interpolation-1","page":"Developer documentation","title":"Interpolation","text":"","category":"section"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"General AbstractArrays may be indexed with WeightedIndex indices, and the result produces the interpolated value. In other words, the end result is just itp.coefs[wis...], where wis is a tuple of WeightedIndex indices.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"Derivatives along a particular axis can be computed just by substituting a component of wis for one that has been designed to compute derivatives rather than values.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"As a demonstration, let's see how the following computation occurs:","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"julia> A = reshape(1:27, 3, 3, 3)\n3×3×3 reshape(::UnitRange{Int64}, 3, 3, 3) with eltype Int64:\n[:, :, 1] =\n 1  4  7\n 2  5  8\n 3  6  9\n\n[:, :, 2] =\n 10  13  16\n 11  14  17\n 12  15  18\n\n[:, :, 3] =\n 19  22  25\n 20  23  26\n 21  24  27\n\njulia> itp = interpolate(A, BSpline(Linear()));\n\njulia> x = (1.2, 1.4, 1.7)\n(1.2, 1.4, 1.7)\n\njulia> itp(x...)\n8.7","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"note: Note\nBy using the debugging facilities of an IDE like Juno or VSCode, or using Debugger.jl from the REPL, you can easily step in to the call above and follow along with the description below.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"Aside from details such as bounds-checking, the key call is to Interpolations.weightedindexes:","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"julia> wis = Interpolations.weightedindexes((Interpolations.value_weights,), Interpolations.itpinfo(itp)..., x)\n(Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7)))\n\njulia> wis[1]\nInterpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996))\n\njulia> wis[2]\nInterpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999))\n\njulia> wis[3]\nInterpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7))\n\njulia> A[wis...]\n8.7","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"You can see that each of wis corresponds to a specific position: 1.2, 1.4, and 1.7 respectively. We can index A at wis, and it returns the value of itp(x...), which here is just","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"  0.8 * A[1, wis[2], wis[3]] + 0.2 * A[2, wis[2], wis[3]]\n= 0.6 * (0.8 * A[1, 1, wis[3]] + 0.2 * A[2, 1, wis[3]]) +\n  0.4 * (0.8 * A[1, 2, wis[3]] + 0.2 * A[2, 2, wis[3]])\n= 0.3 * (0.6 * (0.8 * A[1, 1, 1] + 0.2 * A[2, 1, 1]) +\n         0.4 * (0.8 * A[1, 2, 1] + 0.2 * A[2, 2, 1])  ) +\n  0.7 * (0.6 * (0.8 * A[1, 1, 2] + 0.2 * A[2, 1, 2]) +\n         0.4 * (0.8 * A[1, 2, 2] + 0.2 * A[2, 2, 2])  )","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"This computed the value of itp at x... because we called weightedindexes with just a single function, Interpolations.value_weights (meaning, \"the weights needed to compute the value\").","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"note: Note\nRemember that prefiltering is not used for Linear interpolation. In a case where prefiltering is used, we would substitute itp.coefs[wis...] for A[wis...] above.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"To compute derivatives, we also pass additional functions like Interpolations.gradient_weights:","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"julia> wis = Interpolations.weightedindexes((Interpolations.value_weights, Interpolations.gradient_weights), Interpolations.itpinfo(itp)..., x)\n((Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7))), (Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7))), (Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0))))\n\njulia> wis[1]\n(Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7)))\n\njulia> wis[2]\n(Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.30000000000000004, 0.7)))\n\njulia> wis[3]\n(Interpolations.WeightedAdjIndex{2,Float64}(1, (0.8, 0.19999999999999996)), Interpolations.WeightedAdjIndex{2,Float64}(1, (0.6000000000000001, 0.3999999999999999)), Interpolations.WeightedAdjIndex{2,Float64}(1, (-1.0, 1.0)))\n\njulia> A[wis[1]...]\n1.0\n\njulia> A[wis[2]...]\n3.000000000000001\n\njulia> A[wis[3]...]\n9.0","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"In this case you can see that wis is a 3-tuple-of-3-tuples. A[wis[i]...] can be used to compute the ith component of the gradient.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"If you look carefully at each of the entries in wis, you'll see that each \"inner\" 3-tuple copies two of the three elements in the wis we obtained when we called weightedindexes with just value_weights above. wis[1] replaces the first entry with a weighted index having weights (-1.0, 1.0), which corresponds to computing the slope along this dimension. Likewise wis[2] and wis[3] replace the second and third value-index, respectively, with the same slope computation.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"Hessian computation is quite similar, with the difference that one sometimes needs to replace two different indices or the same index with a set of weights corresponding to a second derivative.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"Consequently derivatives along particular directions are computed simply by \"weight replacement\" along the corresponding dimensions.","category":"page"},{"location":"devdocs/#","page":"Developer documentation","title":"Developer documentation","text":"The code to do this replacement is a bit complicated due to the need to support arbitrary dimensionality in a manner that allows Julia's type-inference to succeed. It makes good use of tuple manipulations, sometimes called \"lispy tuple programming.\" You can search Julia's discourse forum for more tips about how to program this way. It could alternatively be done using generated functions, but this would increase compile time considerably and can lead to world-age problems.","category":"page"}]
}
