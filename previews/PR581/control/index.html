<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interpolation algorithms · Interpolations.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Interpolations.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../convenience-construction/">Convenience Constructors</a></li><li><a class="tocitem" href="../interpolations/">General usage</a></li><li class="is-active"><a class="tocitem" href>Interpolation algorithms</a><ul class="internal"><li><a class="tocitem" href="#Control-of-interpolation-algorithm"><span>Control of interpolation algorithm</span></a></li><li><a class="tocitem" href="#Parametric-splines"><span>Parametric splines</span></a></li><li><a class="tocitem" href="#Monotonic-interpolation"><span>Monotonic interpolation</span></a></li></ul></li><li><a class="tocitem" href="../extrapolation/">Extrapolation</a></li><li><a class="tocitem" href="../iterate/">Knot Iteration</a></li><li><a class="tocitem" href="../devdocs/">Developer documentation</a></li><li><a class="tocitem" href="../api/">Library</a></li><li><a class="tocitem" href="../NEWS/">News and Changes</a></li><li><a class="tocitem" href="../other_packages/">Other Interpolation Packages</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interpolation algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interpolation algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/Interpolations.jl/blob/master/docs/src/control.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Control-of-interpolation-algorithm"><a class="docs-heading-anchor" href="#Control-of-interpolation-algorithm">Control of interpolation algorithm</a><a id="Control-of-interpolation-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Control-of-interpolation-algorithm" title="Permalink"></a></h2><h3 id="BSplines"><a class="docs-heading-anchor" href="#BSplines">BSplines</a><a id="BSplines-1"></a><a class="docs-heading-anchor-permalink" href="#BSplines" title="Permalink"></a></h3><p>The interpolation type is described in terms of <em>degree</em> and, if necessary, <em>boundary conditions</em>. There are currently four degrees available: <code>Constant</code>, <code>Linear</code>, <code>Quadratic</code>,  and <code>Cubic</code> corresponding to B-splines of degree 0, 1, 2, and 3 respectively.</p><p>B-splines of quadratic or higher degree require solving an equation system to obtain the interpolation coefficients, and for that you must specify a <em>boundary condition</em> that is applied to close the system. The following boundary conditions are implemented: <code>Flat</code>, <code>Line</code> (alternatively, <code>Natural</code>), <code>Free</code>, <code>Periodic</code> and <code>Reflect</code>; their mathematical implications are described in detail in their docstrings. When specifying these boundary conditions you also have to specify whether they apply at the edge grid point (<code>OnGrid()</code>) or beyond the edge point halfway to the next (fictitious) grid point (<code>OnCell()</code>).</p><p>Some examples:</p><pre><code class="language-julia hljs"># Nearest-neighbor interpolation
itp = interpolate(a, BSpline(Constant()))
v = itp(5.4)   # returns a[5]

# Previous-neighbor interpolation
itp = interpolate(a, BSpline(Constant(Previous)))
v = itp(1.8)   # returns a[1]

# Next-neighbor interpolation
itp = interpolate(a, BSpline(Constant(Next)))
v = itp(5.4)   # returns a[6]

# (Multi)linear interpolation
itp = interpolate(A, BSpline(Linear()))
v = itp(3.2, 4.1)  # returns 0.9*(0.8*A[3,4]+0.2*A[4,4]) + 0.1*(0.8*A[3,5]+0.2*A[4,5])

# Quadratic interpolation with reflecting boundary conditions
# Quadratic is the lowest order that has continuous gradient
itp = interpolate(A, BSpline(Quadratic(Reflect(OnCell()))))

# Linear interpolation in the first dimension, and no interpolation (just lookup) in the second
itp = interpolate(A, (BSpline(Linear()), NoInterp()))
v = itp(3.65, 5)  # returns  0.35*A[3,5] + 0.65*A[4,5]</code></pre><p>There are more options available, for example:</p><pre><code class="language-julia hljs"># In-place interpolation
itp = interpolate!(A, BSpline(Quadratic(InPlace(OnCell()))))</code></pre><p>which destroys the input <code>A</code> but also does not need to allocate as much memory.</p><h3 id="Scaled-BSplines"><a class="docs-heading-anchor" href="#Scaled-BSplines">Scaled BSplines</a><a id="Scaled-BSplines-1"></a><a class="docs-heading-anchor-permalink" href="#Scaled-BSplines" title="Permalink"></a></h3><p>BSplines assume your data is uniformly spaced on the grid <code>1:N</code>, or its multidimensional equivalent. If you have data of the form <code>[f(x) for x in A]</code>, you need to tell Interpolations about the grid <code>A</code>. If <code>A</code> is not uniformly spaced, you must use gridded interpolation described below. However, if <code>A</code> is a collection of ranges or linspaces, you can use scaled BSplines. This is more efficient because the gridded algorithm does not exploit the uniform spacing. Scaled BSplines can also be used with any spline degree available for BSplines, while gridded interpolation does not currently support quadratic or cubic splines.</p><p>Some examples,</p><pre><code class="language-julia hljs">A_x = 1.:2.:40.
A = [log(x) for x in A_x]
itp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))
sitp = scale(itp, A_x)
sitp(3.) # exactly log(3.)
sitp(3.5) # approximately log(3.5)</code></pre><p>For multidimensional uniformly spaced grids</p><pre><code class="language-julia hljs">A_x1 = 1:.1:10
A_x2 = 1:.5:20
f(x1, x2) = log(x1+x2)
A = [f(x1,x2) for x1 in A_x1, x2 in A_x2]
itp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))
sitp = scale(itp, A_x1, A_x2)
sitp(5., 10.) # exactly log(5 + 10)
sitp(5.6, 7.1) # approximately log(5.6 + 7.1)</code></pre><h3 id="Gridded-interpolation"><a class="docs-heading-anchor" href="#Gridded-interpolation">Gridded interpolation</a><a id="Gridded-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Gridded-interpolation" title="Permalink"></a></h3><p>These use a very similar syntax to BSplines, with the major exception being that one does not get to choose the grid representation (they are all <code>OnGrid</code>). As such one must specify a set of coordinate arrays defining the nodes of the array.</p><p>In 1D</p><pre><code class="language-julia hljs">A = rand(20)
A_x = 1.0:2.0:40.0
nodes = (A_x,)
itp = interpolate(nodes, A, Gridded(Linear()))
itp(2.0)</code></pre><p>The spacing between adjacent samples need not be constant; indeed, if they are constant, you&#39;ll get better performance with <code>scaled</code>.</p><p>The general syntax is</p><pre><code class="language-julia hljs">itp = interpolate(nodes, A, options...)</code></pre><p>where <code>nodes = (xnodes, ynodes, ...)</code> specifies the positions along each axis at which the array <code>A</code> is sampled for arbitrary (&quot;rectangular&quot;) samplings.</p><p>For example:</p><pre><code class="language-julia hljs">A = rand(8,20)
nodes = ([x^2 for x = 1:8], [0.2y for y = 1:20])
itp = interpolate(nodes, A, Gridded(Linear()))
itp(4,1.2)  # approximately A[2,6]</code></pre><p>One may also mix modes, by specifying a mode vector in the form of an explicit tuple:</p><pre><code class="language-julia hljs">itp = interpolate(nodes, A, (Gridded(Linear()),Gridded(Constant())))</code></pre><p>Presently there are only three modes for gridded:</p><pre><code class="language-julia hljs">Gridded(Linear())</code></pre><p>whereby a linear interpolation is applied between nodes,</p><pre><code class="language-julia hljs">Gridded(Constant())</code></pre><p>whereby nearest neighbor interpolation is used on the applied axis,</p><pre><code class="language-julia hljs">NoInterp()</code></pre><p>whereby the coordinate of the selected input vector MUST be located on a grid point. Requests for off grid coordinates results in the throwing of an error.</p><p>For <a href="../api/#Interpolations.Constant"><code>Constant</code></a> there are additional parameters. Use <code>Constant{Previous}()</code> in order to perform a previous neighbor interpolation. Use <code>Constant{Next}()</code> for a next neighbor interpolation. Note that rounding can be an issue, see <a href="https://github.com/JuliaMath/Interpolations.jl/issues/473">#473</a>.</p><p><code>missing</code> data will naturally propagate through the interpolation, where some values will become missing. To avoid that, one can filter out the missing data points and use a gridded interpolation. For example:</p><pre><code class="language-julia hljs">x = 1:6
A = [i == 3 ? missing : i for i in x]
xf = [xi for (xi,a) in zip(x, A) if !ismissing(a)]
Af = [a for a in A if !ismissing(a)]
itp = interpolate((xf, ), Af, Gridded(Linear()))</code></pre><p>In-place gridded interpolation is also possible:</p><pre><code class="language-julia hljs">x = 1:4
y = view(rand(4), :)
itp = interpolate!((x,), y, Gridded(Linear()))
y .= 0
@show itp(2.5) # 0</code></pre><h2 id="Parametric-splines"><a class="docs-heading-anchor" href="#Parametric-splines">Parametric splines</a><a id="Parametric-splines-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-splines" title="Permalink"></a></h2><p>Given a set a knots with coordinates <code>x(t)</code> and <code>y(t)</code>, a parametric spline <code>S(t) = (x(t),y(t))</code> parametrized by <code>t in [0,1]</code> can be constructed with the following code adapted from a <a href="http://julia-programming-language.2336112.n4.nabble.com/Parametric-splines-td37794.html#a37818">post</a> by Tomas Lycken:</p><pre><code class="language-julia hljs">using Interpolations

t = 0:.1:1
x = sin.(2π*t)
y = cos.(2π*t)
A = hcat(x,y)

itp = Interpolations.scale(interpolate(A, (BSpline(Cubic(Natural(OnGrid()))), NoInterp())), t, 1:2)

tfine = 0:.01:1
xs, ys = [itp(t,1) for t in tfine], [itp(t,2) for t in tfine]</code></pre><p>We can then plot the spline with:</p><pre><code class="language-julia hljs">using Plots

scatter(x, y, label=&quot;knots&quot;)
plot!(xs, ys, label=&quot;spline&quot;)</code></pre><p><img src="../assets/parametric_spline.png" alt="parametric spline"/></p><h2 id="Monotonic-interpolation"><a class="docs-heading-anchor" href="#Monotonic-interpolation">Monotonic interpolation</a><a id="Monotonic-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Monotonic-interpolation" title="Permalink"></a></h2><p>When you have some one-dimensional data that is monotonic, many standard interpolation methods may give an interpolating function that it is not monotonic. Monotonic interpolation ensures that the interpolating function is also monotonic.</p><p>Here is an example of making a cumulative distribution function for some data:</p><pre><code class="language-julia hljs">percentile_values = [0.0, 0.01, 0.1, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 99.9, 99.99, 100.0];

y = sort(randn(length(percentile_values))); # some random data

itp_cdf = extrapolate(interpolate(y, percentile_values, SteffenMonotonicInterpolation()), Flat());

t = -3.0:0.01:3.0 # just a range for calculating values of the interpolating function

interpolated_cdf = map(itp_cdf, t) # interpolating the CDF</code></pre><p>There are a few different monotonic interpolation algorithms. Some guarantee that for non-monotonic data the interpolating function does not exceed the range of values between two successive points while other do not (this is called overshooting in the list below).</p><ul><li><a href="../api/#Interpolations.LinearMonotonicInterpolation"><code>LinearMonotonicInterpolation</code></a> – simple linear interpolation. Does not overshoot.</li><li><a href="../api/#Interpolations.FiniteDifferenceMonotonicInterpolation"><code>FiniteDifferenceMonotonicInterpolation</code></a> – it may overshoot.</li><li><a href="../api/#Interpolations.CardinalMonotonicInterpolation"><code>CardinalMonotonicInterpolation</code></a> – it may overshoot.</li><li><a href="../api/#Interpolations.FritschCarlsonMonotonicInterpolation"><code>FritschCarlsonMonotonicInterpolation</code></a> – it may overshoot.</li><li><a href="../api/#Interpolations.FritschButlandMonotonicInterpolation"><code>FritschButlandMonotonicInterpolation</code></a> – it does not overshoot.</li><li><a href="../api/#Interpolations.SteffenMonotonicInterpolation"><code>SteffenMonotonicInterpolation</code></a> – it does not overshoot.</li></ul><p>You can read about monotonic interpolation in the following sources:</p><ul><li>Fritsch &amp; Carlson (1980), &quot;Monotone Piecewise Cubic Interpolation&quot;, doi:10.1137/0717021.</li><li>Fritsch &amp; Butland (1984), &quot;A Method for Constructing Local Monotone Piecewise Cubic Interpolants&quot;, doi:10.1137/0905021.</li><li>Steffen (1990), &quot;A Simple Method for Monotonic Interpolation in One Dimension&quot;, <a href="http://adsabs.harvard.edu/abs/1990A%26A...239..443S">URL</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interpolations/">« General usage</a><a class="docs-footer-nextpage" href="../extrapolation/">Extrapolation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 30 January 2024 14:35">Tuesday 30 January 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
