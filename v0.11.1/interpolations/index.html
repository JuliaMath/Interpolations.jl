<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General usage · Interpolations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Interpolations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>General usage</a><ul class="internal"><li><a class="toctext" href="#General-usage-1">General usage</a></li></ul></li><li><a class="toctext" href="../control/">Interpolation algorithms</a></li><li><a class="toctext" href="../extrapolation/">Extrapolation</a></li><li><a class="toctext" href="../convenience-construction/">Convenience Construcors</a></li><li><a class="toctext" href="../api/">Library</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>General usage</a></li></ul><a class="edit-page" href="https://github.com/JuliaMath/Interpolations.jl/blob/master/docs/src/interpolations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>General usage</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="General-usage-1" href="#General-usage-1">General usage</a></h2><p>Note: the current version of <code>Interpolations</code> supports interpolation evaluation using index calls <code>[]</code>, but this feature will be deprecated in future. We highly recommend function calls with <code>()</code> as follows.</p><p>Given an <code>AbstractArray</code> <code>A</code>, construct an &quot;interpolation object&quot; <code>itp</code> as</p><pre><code class="language-julia">itp = interpolate(A, options...)</code></pre><p>where <code>options...</code> (discussed below) controls the type of interpolation you want to perform.  This syntax assumes that the samples in <code>A</code> are equally-spaced.</p><p>To evaluate the interpolation at position <code>(x, y, ...)</code>, simply do</p><pre><code class="language-julia">v = itp(x, y, ...)</code></pre><p>Some interpolation objects support computation of the gradient, which can be obtained as</p><pre><code class="language-julia">g = Interpolations.gradient(itp, x, y, ...)</code></pre><p>or as</p><pre><code class="language-julia">Interpolations.gradient!(g, itp, x, y, ...)</code></pre><p>where <code>g</code> is a pre-allocated vector.</p><p>Some interpolation objects support computation of the hessian, which can be obtained as</p><pre><code class="language-julia">h = Interpolations.hessian(itp, x, y, ...)</code></pre><p>or</p><pre><code class="language-julia">Interpolations.hessian!(h, itp, x, y, ...)</code></pre><p>where <code>h</code> is a pre-allocated matrix.</p><p><code>A</code> may have any element type that supports the operations of addition and multiplication.  Examples include scalars like <code>Float64</code>, <code>Int</code>, and <code>Rational</code>, but also multi-valued types like <code>RGB</code> color vectors.</p><p>Positions <code>(x, y, ...)</code> are n-tuples of numbers. Typically these will be real-valued (not necessarily integer-valued), but can also be of types such as <a href="https://github.com/JuliaDiff/DualNumbers.jl">DualNumbers</a> if you want to verify the computed value of gradients. (Alternatively, verify gradients using <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff</a>.) You can also use Julia&#39;s iterator objects, e.g.,</p><pre><code class="language-julia">function ongrid!(dest, itp)
    for I in CartesianIndices(itp)
        dest[I] = itp(I)
    end
end</code></pre><p>would store the on-grid value at each grid point of <code>itp</code> in the output <code>dest</code>. Finally, courtesy of Julia&#39;s indexing rules, you can also use</p><pre><code class="language-julia">fine = itp(range(1,stop=10,length=1001), range(1,stop=15,length=201))</code></pre><p>There is also an abbreviated <a href="../convenience-construction/#Convenience-notation-1">Convenience notation</a>.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../control/"><span class="direction">Next</span><span class="title">Interpolation algorithms</span></a></footer></article></body></html>
