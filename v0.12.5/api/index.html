<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Interpolations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Interpolations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../interpolations/">General usage</a></li><li><a class="toctext" href="../control/">Interpolation algorithms</a></li><li><a class="toctext" href="../extrapolation/">Extrapolation</a></li><li><a class="toctext" href="../convenience-construction/">Convenience Constructors</a></li><li class="current"><a class="toctext" href>Library</a><ul class="internal"><li><a class="toctext" href="#Public-API-1">Public API</a></li><li><a class="toctext" href="#Internal-API-1">Internal API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Library</a></li></ul><a class="edit-page" href="https://github.com/JuliaMath/Interpolations.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Library</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="Public-API-1" href="#Public-API-1">Public API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.CubicSplineInterpolation" href="#Interpolations.CubicSplineInterpolation"><code>Interpolations.CubicSplineInterpolation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">etp = CubicSplineInterpolation(knots, A; bc=Line(OnGrid()), extrapolation_bc=Throw())</code></pre><p>A shorthand for <code>extrapolate(interpolate(knots, A, BSpline(Cubic(bc))), extrapolation_bc)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/convenience-constructors.jl#L31-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.LinearInterpolation" href="#Interpolations.LinearInterpolation"><code>Interpolations.LinearInterpolation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">etp = LinearInterpolation(knots, A; extrapolation_bc=Throw())</code></pre><p>A shorthand for <code>extrapolate(interpolate(knots, A, scheme), extrapolation_bc)</code>, where <code>scheme</code> is either <code>BSpline(Linear())</code> or <code>Gridded(Linear())</code> depending on whether <code>knots</code> are ranges or vectors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/convenience-constructors.jl#L22-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.extrapolate-Union{Tuple{ET}, Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},ET}} where ET&lt;:Union{Tuple{Vararg{Union{Tuple{BoundaryCondition,BoundaryCondition}, BoundaryCondition},N} where N}, BoundaryCondition} where IT where N where T" href="#Interpolations.extrapolate-Union{Tuple{ET}, Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},ET}} where ET&lt;:Union{Tuple{Vararg{Union{Tuple{BoundaryCondition,BoundaryCondition}, BoundaryCondition},N} where N}, BoundaryCondition} where IT where N where T"><code>Interpolations.extrapolate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>extrapolate(itp, scheme)</code> adds extrapolation behavior to an interpolation object, according to the provided scheme.</p><p>The scheme can take any of these values:</p><ul><li><code>Throw</code> - throws a BoundsError for out-of-bounds indices</li><li><code>Flat</code> - for constant extrapolation, taking the closest in-bounds value</li><li><code>Line</code> - linear extrapolation (the wrapped interpolation object must support gradient)</li><li><code>Reflect</code> - reflecting extrapolation (indices must support <code>mod</code>)</li><li><code>Periodic</code> - periodic extrapolation (indices must support <code>mod</code>)</li></ul><p>You can also combine schemes in tuples. For example, the scheme <code>(Line(), Flat())</code> will use linear extrapolation in the first dimension, and constant in the second.</p><p>Finally, you can specify different extrapolation behavior in different direction. <code>((Line(),Flat()), Flat())</code> will extrapolate linearly in the first dimension if the index is too small, but use constant etrapolation if it is too large, and always use constant extrapolation in the second dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/extrapolation/extrapolation.jl#L25-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.extrapolate-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},Any}} where IT where N where T" href="#Interpolations.extrapolate-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},Any}} where IT where N where T"><code>Interpolations.extrapolate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>extrapolate(itp, fillvalue)</code> creates an extrapolation object that returns the <code>fillvalue</code> any time the indexes in <code>itp(x1,x2,...)</code> are out-of-bounds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/extrapolation/filled.jl#L25-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray,IT}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline},N} where N}, BSpline}" href="#Interpolations.interpolate-Union{Tuple{IT}, Tuple{AbstractArray,IT}} where IT&lt;:Union{NoInterp, Tuple{Vararg{Union{NoInterp, BSpline},N} where N}, BSpline}"><code>Interpolations.interpolate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">itp = interpolate(A, interpmode, gridstyle)</code></pre><p>Interpolate an array <code>A</code> in the mode determined by <code>interpmode</code> and <code>gridstyle</code>. <code>interpmode</code> may be one of</p><ul><li><code>BSpline(NoInterp())</code></li><li><code>BSpline(Linear())</code></li><li><code>BSpline(Quadratic(BC()))</code> (see <a href="#Interpolations.BoundaryCondition"><code>BoundaryCondition</code></a>)</li><li><code>BSpline(Cubic(BC()))</code></li></ul><p>It may also be a tuple of such values, if you want to use different interpolation schemes along each axis.</p><p><code>gridstyle</code> should be one of <code>OnGrid()</code> or <code>OnCell()</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/b-splines.jl#L136-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.scale-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},Vararg{AbstractRange,N}}} where IT where N where T" href="#Interpolations.scale-Union{Tuple{IT}, Tuple{N}, Tuple{T}, Tuple{AbstractInterpolation{T,N,IT},Vararg{AbstractRange,N}}} where IT where N where T"><code>Interpolations.scale</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>scale(itp, xs, ys, ...)</code> scales an existing interpolation object to allow for indexing using other coordinate axes than unit ranges, by wrapping the interpolation object and transforming the indices from the provided axes onto unit ranges upon indexing.</p><p>The parameters <code>xs</code> etc must be either ranges or linspaces, and there must be one coordinate range/linspace for each dimension of the interpolation object.</p><p>For every <code>NoInterp</code> dimension of the interpolation object, the range must be exactly <code>1:size(itp, d)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/scaling/scaling.jl#L20-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.CardinalMonotonicInterpolation" href="#Interpolations.CardinalMonotonicInterpolation"><code>Interpolations.CardinalMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CardinalMonotonicInterpolation(tension)</code></pre><p>Cubic cardinal splines, uses <code>tension</code> parameter which must be between [0,1] Cubin cardinal splines can overshoot for non-monotonic data (increasing tension reduces overshoot).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/monotonic/monotonic.jl#L56-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.Constant" href="#Interpolations.Constant"><code>Interpolations.Constant</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Constant b-splines are <em>nearest-neighbor</em> interpolations, and effectively return <code>A[round(Int,x)]</code> when interpolating.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/constant.jl#L3-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.Cubic" href="#Interpolations.Cubic"><code>Interpolations.Cubic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Assuming uniform knots with spacing 1, the <code>i</code>th piece of cubic spline implemented here is defined as follows.</p><pre><code class="language-none">y_i(x) = cm p(x-i) + c q(x-i) + cp q(1- (x-i)) + cpp p(1 - (x-i))</code></pre><p>where</p><pre><code class="language-none">p(δx) = 1/6 * (1-δx)^3
q(δx) = 2/3 - δx^2 + 1/2 δx^3</code></pre><p>and the values <code>cX</code> for <code>X ∈ {m, _, p, pp}</code> are the pre-filtered coefficients.</p><p>For future reference, this expands out to the following polynomial:</p><pre><code class="language-none">y_i(x) = 1/6 cm (1+i-x)^3 + c (2/3 - (x-i)^2 + 1/2 (x-i)^3) +
         cp (2/3 - (1+i-x)^2 + 1/2 (1+i-x)^3) + 1/6 cpp (x-i)^3</code></pre><p>When we derive boundary conditions we will use derivatives <code>y_0&#39;(x)</code> and <code>y_0&#39;&#39;(x)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/cubic.jl#L7-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.FiniteDifferenceMonotonicInterpolation" href="#Interpolations.FiniteDifferenceMonotonicInterpolation"><code>Interpolations.FiniteDifferenceMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FiniteDifferenceMonotonicInterpolation</code></pre><p>Classic cubic interpolation, no tension parameter. Finite difference can overshoot for non-monotonic data.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/monotonic/monotonic.jl#L47-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.FritschButlandMonotonicInterpolation" href="#Interpolations.FritschButlandMonotonicInterpolation"><code>Interpolations.FritschButlandMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FritschButlandMonotonicInterpolation</code></pre><p>Monotonic interpolation based on  Fritsch &amp; Butland (1984), &quot;A Method for Constructing Local Monotone Piecewise Cubic Interpolants&quot;, doi:10.1137/0905021.</p><p>Faster than FritschCarlsonMonotonicInterpolation (only requires one pass) but somewhat higher apparent &quot;tension&quot;.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/monotonic/monotonic.jl#L79-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.FritschCarlsonMonotonicInterpolation" href="#Interpolations.FritschCarlsonMonotonicInterpolation"><code>Interpolations.FritschCarlsonMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FritschCarlsonMonotonicInterpolation</code></pre><p>Monotonic interpolation based on Fritsch &amp; Carlson (1980), &quot;Monotone Piecewise Cubic Interpolation&quot;, doi:10.1137/0717021.</p><p>Tangents are first initialized, then adjusted if they are not monotonic can overshoot for non-monotonic data</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/monotonic/monotonic.jl#L67-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.Linear" href="#Interpolations.Linear"><code>Interpolations.Linear</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Assuming uniform knots with spacing 1, the <code>i</code>th piece of linear b-spline implemented here is defined as follows.</p><pre><code class="language-none">y_i(x) = c p(x) + cp p(1-x)</code></pre><p>where</p><pre><code class="language-none">p(δx) = x</code></pre><p>and the values <code>cX</code> for <code>X ∈ {_, p}</code> are the coefficients.</p><p>Linear b-splines are naturally interpolating, and require no prefiltering; there is therefore no need for boundary conditions to be provided.</p><p>Also, although the implementation is slightly different in order to re-use the framework built for general b-splines, the resulting interpolant is just a piecewise linear function connecting each pair of neighboring data points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/linear.jl#L3-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.LinearMonotonicInterpolation" href="#Interpolations.LinearMonotonicInterpolation"><code>Interpolations.LinearMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LinearMonotonicInterpolation</code></pre><p>Simple linear interpolation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/monotonic/monotonic.jl#L39-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.Quadratic" href="#Interpolations.Quadratic"><code>Interpolations.Quadratic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Assuming uniform knots with spacing 1, the <code>i</code>th piece of quadratic spline implemented here is defined as follows:</p><pre><code class="language-none">y_i(x) = cm p(x-i) + c q(x) + cp p(1-(x-i))</code></pre><p>where</p><pre><code class="language-none">p(δx) = (δx - 1)^2 / 2
q(δx) = 3/4 - δx^2</code></pre><p>and the values for <code>cX</code> for <code>X ∈ {m,_,p}</code> are the pre-filtered coefficients.</p><p>For future reference, this expands to the following polynomial:</p><pre><code class="language-none">y_i(x) = cm * 1/2 * (x-i-1)^2 + c * (3/4 - x + i)^2 + cp * 1/2 * (x-i)^2</code></pre><p>When we derive boundary conditions we will use derivatives <code>y_1&#39;(x-1)</code> and <code>y_1&#39;&#39;(x-1)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/quadratic.jl#L7-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.SteffenMonotonicInterpolation" href="#Interpolations.SteffenMonotonicInterpolation"><code>Interpolations.SteffenMonotonicInterpolation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SteffenMonotonicInterpolation</code></pre><p>Monotonic interpolation based on Steffen (1990), &quot;A Simple Method for Monotonic Interpolation in One Dimension&quot;, http://adsabs.harvard.edu/abs/1990A%26A...239..443S</p><p>Only one pass, results usually between FritschCarlson and FritschButland.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/monotonic/monotonic.jl#L92-L100">source</a></section><h2><a class="nav-anchor" id="Internal-API-1" href="#Internal-API-1">Internal API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.boundstep" href="#Interpolations.boundstep"><code>Interpolations.boundstep</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Returns <em>half</em> the width of one step of the range.</p><p>This function is used to calculate the upper and lower bounds of <code>OnCell</code> interpolation objects.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/scaling/scaling.jl#L58-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.count_interp_dims-Union{Tuple{Type{ITP}}, Tuple{ITP}} where ITP&lt;:AbstractInterpolation" href="#Interpolations.count_interp_dims-Union{Tuple{Type{ITP}}, Tuple{ITP}} where ITP&lt;:AbstractInterpolation"><code>Interpolations.count_interp_dims</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">n = count_interp_dims(ITP)</code></pre><p>Count the number of dimensions along which type <code>ITP</code> is interpolating. <code>NoInterp</code> dimensions do not contribute to the sum.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/Interpolations.jl#L126-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.gradient_weights" href="#Interpolations.gradient_weights"><code>Interpolations.gradient_weights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">w = gradient_weights(degree, δx)</code></pre><p>Compute the weights for interpolation of the gradient at an offset <code>δx</code> from the &quot;base&quot; position. <code>degree</code> describes the interpolation scheme.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Interpolations.gradient_weights(Linear(), 0.2)
(-1.0, 1.0)</code></pre><p>This defines the gradient of a linear interpolation at 3.2 as <code>y[4] - y[3]</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/Interpolations.jl#L326-L340">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.hessian_weights" href="#Interpolations.hessian_weights"><code>Interpolations.hessian_weights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">w = hessian_weights(degree, δx)</code></pre><p>Compute the weights for interpolation of the hessian at an offset <code>δx</code> from the &quot;base&quot; position. <code>degree</code> describes the interpolation scheme.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Interpolations.hessian_weights(Linear(), 0.2)
(0.0, 0.0)</code></pre><p>Linear interpolation uses straight line segments, so the second derivative is zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/Interpolations.jl#L343-L357">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.inner_system_diags" href="#Interpolations.inner_system_diags"><code>Interpolations.inner_system_diags</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dl, d, du = inner_system_diags{T,IT}(::Type{T}, n::Int, ::Type{IT})</code></pre><p>Helper function to generate the prefiltering equation system: generates the diagonals for a <code>n</code>-by-<code>n</code> tridiagonal matrix with eltype <code>T</code> corresponding to the interpolation type <code>IT</code>.</p><p><code>dl</code>, <code>d</code>, and <code>du</code> are intended to be used e.g. as in <code>M = Tridiagonal(dl, d, du)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/prefiltering.jl#L100-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.inner_system_diags-Union{Tuple{T}, Tuple{Type{T},Int64,Cubic}} where T" href="#Interpolations.inner_system_diags-Union{Tuple{T}, Tuple{Type{T},Int64,Cubic}} where T"><code>Interpolations.inner_system_diags</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Cubic</code>: continuity in function value, first and second derivatives yields</p><pre><code class="language-none">2/3 1/6
1/6 2/3 1/6
    1/6 2/3 1/6
       ⋱  ⋱   ⋱</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/cubic.jl#L71-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system" href="#Interpolations.prefiltering_system"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">M, b = prefiltering_system{T,TC,GT&lt;:GridType,D&lt;:Degree}m(::T, ::Type{TC}, n::Int, ::Type{D}, ::Type{GT})</code></pre><p>Given element types (<code>T</code>, <code>TC</code>) and interpolation scheme (<code>GT</code>, <code>D</code>) as well the number of rows in the data input (<code>n</code>), compute the system used to prefilter spline coefficients. Boundary conditions determine the values on the first and last rows.</p><p>Some of these boundary conditions require that these rows have off-tridiagonal elements (e.g the <code>[1,3]</code> element of the matrix). To maintain the efficiency of solving tridiagonal systems, the <a href="https://en.wikipedia.org/wiki/Woodbury_matrix_identity">Woodbury matrix identity</a> is used to add additional elements off the main 3 diagonals.</p><p>The filtered coefficients are given by solving the equation system</p><pre><code class="language-none">M * c = v + b</code></pre><p>where <code>c</code> are the sought coefficients, and <code>v</code> are the data points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/prefiltering.jl#L79-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{BC}}} where BC&lt;:Union{Flat{OnCell}, Reflect{OnCell}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{BC}}} where BC&lt;:Union{Flat{OnCell}, Reflect{OnCell}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Quadratic{Flat}</code> <code>OnCell</code> and <code>Quadratic{Reflect}</code> <code>OnCell</code> amounts to setting <code>y_1&#39;(x) = 0</code> at x=1/2. Applying this condition yields</p><pre><code class="language-none">-cm + c = 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/quadratic.jl#L68-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{BC}}} where BC&lt;:Union{Flat{OnGrid}, Reflect{OnGrid}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{BC}, Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{BC}}} where BC&lt;:Union{Flat{OnGrid}, Reflect{OnGrid}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Quadratic{Flat}</code> <code>OnGrid</code> and <code>Quadratic{Reflect}</code> <code>OnGrid</code> amount to setting <code>y_1&#39;(x) = 0</code> at <code>x=1</code>. Applying this condition yields</p><pre><code class="language-none">-cm + cp = 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/quadratic.jl#L102-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{#s12} where #s12&lt;:Free}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{#s12} where #s12&lt;:Free}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Cubic{Free}</code> <code>OnGrid</code> and <code>Cubic{Free}</code> <code>OnCell</code> amount to requiring an extra continuous derivative at the second-to-last cell boundary; this means <code>y_1&#39;&#39;&#39;(2) = y_2&#39;&#39;&#39;(2)</code>, yielding</p><pre><code class="language-none">1 cm -3 c + 3 cp -1 cpp = 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/cubic.jl#L208-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{#s12} where #s12&lt;:Periodic}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{#s12} where #s12&lt;:Periodic}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Cubic{Periodic}</code> <code>OnGrid</code> closes the system by looking at the coefficients themselves as periodic, yielding</p><pre><code class="language-none">c0 = c(N+1)</code></pre><p>where <code>N</code> is the number of data points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/cubic.jl#L188-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Flat{OnCell}}}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Flat{OnCell}}}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Cubic{Flat}</code>, <code>OnCell</code> amounts to setting <code>y_1&#39;(x) = 0</code> at <code>x = 1/2</code>. Applying this condition yields</p><pre><code class="language-none">-9/8 cm + 11/8 c - 3/8 cp + 1/8 cpp = 0</code></pre><p>or, equivalently,</p><pre><code class="language-none">-9 cm + 11 c -3 cp + 1 cpp = 0</code></pre><p>(Note that we use <code>y_1&#39;(x)</code> although it is strictly not valid in this domain; if we were to use <code>y_0&#39;(x)</code> we would have to introduce new coefficients, so that would not close the system. Instead, we extend the outermost polynomial for an extra half-cell.)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/cubic.jl#L104-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Flat{OnGrid}}}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Flat{OnGrid}}}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Cubic{Flat}</code> <code>OnGrid</code> amounts to setting <code>y_1&#39;(x) = 0</code> at <code>x = 1</code>. Applying this condition yields</p><pre><code class="language-none">-cm + cp = 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/cubic.jl#L86-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Line{OnCell}}}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Line{OnCell}}}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Cubic{Line}</code> <code>OnCell</code> amounts to setting <code>y_1&#39;&#39;(x) = 0</code> at <code>x = 1/2</code>. Applying this condition yields</p><pre><code class="language-none">3 cm -7 c + 5 cp -1 cpp = 0</code></pre><p>(Note that we use <code>y_1&#39;(x)</code> although it is strictly not valid in this domain; if we were to use <code>y_0&#39;(x)</code> we would have to introduce new coefficients, so that would not close the system. Instead, we extend the outermost polynomial for an extra half-cell.)</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/cubic.jl#L137-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Line{OnGrid}}}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Cubic{Line{OnGrid}}}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Cubic{Line}</code> <code>OnGrid</code> amounts to setting <code>y_1&#39;&#39;(x) = 0</code> at <code>x = 1</code>. Applying this condition gives:</p><pre><code class="language-none">1 cm -2 c + 1 cp = 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/cubic.jl#L166-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Free}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Free}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Quadratic{Free}</code> <code>OnGrid</code> and <code>Quadratic{Free}</code> <code>OnCell</code> amount to requiring an extra continuous derivative at the second-to-last cell boundary; this means that <code>y_1&#39;&#39;(3/2) = y_2&#39;&#39;(3/2)</code>, yielding</p><pre><code class="language-none">1 cm -3 c + 3 cp - cpp = 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/quadratic.jl#L141-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Line}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Line}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Quadratic{Line}</code> <code>OnGrid</code> and <code>Quadratic{Line}</code> <code>OnCell</code> amount to setting <code>y_1&#39;&#39;(x) = 0</code> at <code>x=1</code> and <code>x=1/2</code> respectively. Since <code>y_i&#39;&#39;(x)</code> is independent of <code>x</code> for a quadratic b-spline, these both yield</p><pre><code class="language-none">1 cm -2 c + 1 cp = 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/quadratic.jl#L121-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Periodic}} where TC where T" href="#Interpolations.prefiltering_system-Union{Tuple{TC}, Tuple{T}, Tuple{Type{T},Type{TC},Int64,Quadratic{#s12} where #s12&lt;:Periodic}} where TC where T"><code>Interpolations.prefiltering_system</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>Quadratic{Periodic}</code> <code>OnGrid</code> and <code>Quadratic{Periodic}</code> <code>OnCell</code> close the system by looking at the coefficients themselves as periodic, yielding</p><pre><code class="language-none">c0 = c(N+1)</code></pre><p>where <code>N</code> is the number of data points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/b-splines/quadratic.jl#L162-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.rescale_gradient" href="#Interpolations.rescale_gradient"><code>Interpolations.rescale_gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>rescale_gradient(r::AbstractRange)</code></p><p>Implements the chain rule dy/dx = dy/du * du/dx for use when calculating gradients with scaled interpolation objects.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/scaling/scaling.jl#L134-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.show_ranged-Tuple{IO,Any,Any}" href="#Interpolations.show_ranged-Tuple{IO,Any,Any}"><code>Interpolations.show_ranged</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">show_ranged(io, X, knots)</code></pre><p>A replacement for the default array-<code>show</code> for types that may not have the canonical evaluation points. <code>rngs</code> is the tuple of knots along each axis.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/io.jl#L85-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.value_weights" href="#Interpolations.value_weights"><code>Interpolations.value_weights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">w = value_weights(degree, δx)</code></pre><p>Compute the weights for interpolation of the value at an offset <code>δx</code> from the &quot;base&quot; position. <code>degree</code> describes the interpolation scheme.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; Interpolations.value_weights(Linear(), 0.2)
(0.8, 0.2)</code></pre><p>This corresponds to the fact that linear interpolation at <code>x + 0.2</code> is <code>0.8*y[x] + 0.2*y[x+1]</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/Interpolations.jl#L309-L323">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.BoundaryCondition" href="#Interpolations.BoundaryCondition"><code>Interpolations.BoundaryCondition</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BoundaryCondition</code></pre><p>An abstract type with one of the following values (see the help for each for details):</p><ul><li><code>Throw(gt)</code></li><li><code>Flat(gt)</code></li><li><code>Line(gt)</code></li><li><code>Free(gt)</code></li><li><code>Periodic(gt)</code></li><li><code>Reflect(gt)</code></li><li><code>InPlace(gt)</code></li><li><code>InPlaceQ(gt)</code></li></ul><p>where <code>gt</code> is the grid type, e.g., <code>OnGrid()</code> or <code>OnCell()</code>. <code>OnGrid</code> means that the boundary condition &quot;activates&quot; at the first and/or last integer location within the interpolation region, <code>OnCell</code> means the interpolation extends a half-integer beyond the edge before activating the boundary condition.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/Interpolations.jl#L61-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.BoundsCheckStyle" href="#Interpolations.BoundsCheckStyle"><code>Interpolations.BoundsCheckStyle</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BoundsCheckStyle(itp)</code></pre><p>A trait to determine dispatch of bounds-checking for <code>itp</code>. Can return <code>NeedsCheck()</code>, in which case bounds-checking is performed, or <code>CheckWillPass()</code> in which case the check will return <code>true</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/Interpolations.jl#L140-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.MonotonicInterpolation" href="#Interpolations.MonotonicInterpolation"><code>Interpolations.MonotonicInterpolation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MonotonicInterpolation</code></pre><p>Monotonic interpolation up to third order represented by type, knots and coefficients.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/monotonic/monotonic.jl#L104-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.MonotonicInterpolationType" href="#Interpolations.MonotonicInterpolationType"><code>Interpolations.MonotonicInterpolationType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MonotonicInterpolationType</code></pre><p>Abstract class for all types of monotonic interpolation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/monotonic/monotonic.jl#L32-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Interpolations.WeightedIndex" href="#Interpolations.WeightedIndex"><code>Interpolations.WeightedIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">wi = WeightedIndex(indexes, weights)</code></pre><p>Construct a weighted index <code>wi</code>, which can be thought of as a generalization of an ordinary array index to the context of interpolation. For an ordinary vector <code>a</code>, <code>a[i]</code> extracts the element at index <code>i</code>. When interpolating, one is typically interested in a range of indexes and the output is some weighted combination of array values at these indexes. For example, for linear interpolation at a location <code>x</code> between integers <code>i</code> and <code>i+1</code>, we have</p><pre><code class="language-none">ret = (1-f)*a[i] + f*a[i+1]</code></pre><p>where <code>f = x-i</code> lies between 0 and 1. This can be represented as <code>a[wi]</code>, where</p><pre><code class="language-none">wi = WeightedIndex(i:i+1, (1-f, f))</code></pre><p>i.e.,</p><pre><code class="language-none">ret = sum(a[indexes] .* weights)</code></pre><p>Linear interpolation thus constructs weighted indices using a 2-tuple for <code>weights</code> and a length-2 <code>indexes</code> range. Higher-order interpolation would involve more positions and weights (e.g., 3-tuples for quadratic interpolation, 4-tuples for cubic).</p><p>In multiple dimensions, separable interpolation schemes are implemented in terms of multiple weighted indices, accessing <code>A[wi1, wi2, ...]</code> where each <code>wi</code> is the <code>WeightedIndex</code> along the corresponding dimension.</p><p>For value interpolation, <code>weights</code> will typically sum to 1. However, for gradient and Hessian computation this will not necessarily be true. For example, the gradient of one-dimensional linear interpolation can be represented as</p><pre><code class="language-none">gwi = WeightedIndex(i:i+1, (-1, 1))
g1 = a[gwi]</code></pre><p>For a three-dimensional array <code>A</code>, one might compute <code>∂A/∂x₂</code> (the second component of the gradient) as <code>A[wi1, gwi2, wi3]</code>, where <code>wi1</code> and <code>wi3</code> are &quot;value&quot; weights and <code>gwi2</code> &quot;gradient&quot; weights.</p><p><code>indexes</code> may be supplied as a range or as a tuple of the same length as <code>weights</code>. The latter is applicable, e.g., for periodic boundary conditions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/Interpolations.jl/blob/00427a60107a4962452a0b5bcc0bfe66830492f2/src/Interpolations.jl#L153-L195">source</a></section><footer><hr/><a class="previous" href="../convenience-construction/"><span class="direction">Previous</span><span class="title">Convenience Constructors</span></a></footer></article></body></html>
